App.Chess.State: App.State
  App.State.new(App.Chess.State.Local, App.Chess.Board)

type App.Chess.State.Local {
  new(
    mouse_pos: Pair<U32, U32>
    selected:  Maybe<Pair<Nat, Nat>>
    team:      Maybe<Bits>
  )
}

App.Chess.Board: Type
  List<Bits>

App.Chess.room: String
  "Chess_Room_260"

App.Chess.scale: U32
  2

App.Chess.tile_size: U32
  64#32


// 010101111001101111011001011101010011001100110011001100110011
// 001100000000000000000000000000000000000000000000000000000000
// 000000000000000000000000000000000000000000000000000000000000
// 000000000000001000100010001000100010001000100100011010001010
// 110010000110010000000000000000000000000000000000000000000000

// empty        -> 0000
// black pawn   -> 0011
// black rook   -> 0101
// black knight -> 0111
// black bishop -> 1001
// black queen  -> 1011
// black king   -> 1101
// white pawn   -> 0010
// white rook   -> 0100
// white knight -> 0110
// white bishop -> 1000
// white queen  -> 1010
// white king   -> 1100
 
// Initial state
App.Chess.init: App.Init<App.Chess.State>
  let turn = 0 // TODO
  let mouse_pos = {0#32 0#32}
  let selected  = none
  let team      = none
  let chunk0    = Bits.trim(60, Nat.to_bits(394554900005204787))
  let chunk1    = Bits.trim(60, Nat.to_bits(216172782113783808))
  let chunk2    = Bits.trim(60, Nat.to_bits(0))
  let chunk3    = Bits.trim(60, Nat.to_bits(37529996904074))
  let chunk4    = Bits.trim(60, Nat.to_bits(902479144078540800))
  let local     = App.Chess.State.Local.new(mouse_pos, selected, team)
  let global    = [chunk0, chunk1, chunk2, chunk3, chunk4]
  App.Store.new<App.Chess.State>(local, global)

// Returns the chunk where the index is
App.Chess.get_chunk(index: Nat, board: App.Chess.Board): Bits
  let chunk = 
    if index <? 60 then
      board[0] <> Bits.e
    else if index <? 120 then  
      board[1] <> Bits.e
    else if index <? 180 then
      board[2] <> Bits.e
    else if index <? 240 then
      board[3] <> Bits.e
    else
      board[4] <> Bits.e
  chunk

// Returns the (x,y) tile
App.Chess.get(x: Nat, y: Nat, board: App.Chess.Board): Bits
  let tile_size = 4 :: Nat
  let index = (x * tile_size) + (y * 8 * tile_size)
  let chunk = App.Chess.get_chunk(index, board)
  let tile = Bits.slice(tile_size, Bits.drop(56 - index % 60, chunk))
  tile
      

App.Chess.canvas(local: App.Chess.State.Local, board: App.Chess.Board, img: VoxBox): VoxBox
  let size = App.Chess.tile_size
  for i from 0 to 64 with img:
    let x = i % 8
    let y = i / 8
    let is_black_tile = Nat.odd(x + y)
    let draw = VoxBox.Draw.image(((Nat.to_u32(x) * size) - 128) + size / 2, ((Nat.to_u32(y) * size) - 128) + size / 2)
    let draw_tile = VoxBox.Draw.rect(Nat.to_u32(x) * size, Nat.to_u32(y) * size, 0, 64, 64)
    let img = if not(is_black_tile) then draw_tile(Col32.new(100,100,100,255), img) else draw_tile(Col32.new(255,255,255,255), img)
    let tile = App.Chess.get(x, y, board)
    switch Bits.eql(tile) {
      Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))): img
      Bits.o(Bits.i(Bits.o(Bits.o(Bits.e)))): draw(2, App.Chess.whitepawn, img)
      Bits.o(Bits.o(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.whiterook, img)
      Bits.o(Bits.i(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.whiteknight, img)
      Bits.o(Bits.o(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.whitebishop, img)
      Bits.o(Bits.i(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.whitequeen, img)
      Bits.o(Bits.o(Bits.i(Bits.i(Bits.e)))): draw(2, App.Chess.whiteking, img)
      Bits.i(Bits.i(Bits.o(Bits.o(Bits.e)))): draw(2, App.Chess.blackpawn, img)
      Bits.i(Bits.o(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.blackrook, img)
      Bits.i(Bits.i(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.blackknight, img)
      Bits.i(Bits.o(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.blackbishop, img)
      Bits.i(Bits.i(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.blackqueen, img)
      Bits.i(Bits.o(Bits.i(Bits.i(Bits.e)))): draw(2, App.Chess.blackking, img)
    } default img
  let selected = local@selected   
  without selected: img
  let {x, y} = {Nat.to_u32(selected@fst), Nat.to_u32(selected@snd)}
  let draw_outline = VoxBox.Draw.rect(x * size, y * size, 0, 64, 64, Col32.new(100,100,100,100), img)
  draw_outline

// Render function
App.Chess.draw(img: VoxBox): App.Draw<App.Chess.State>
  (state)
  let local  = state@local
  let global = state@global
  // Updates canvas
  let new_img = App.Chess.canvas(local, global, img)
  <div>
    {
    DOM.vbox(
      {
        "id": "game_screen",
        "width": U32.show(App.Chess.tile_size * 8)
        "height": U32.show(App.Chess.tile_size * 8)
        "scale": U32.show(App.Chess.scale)
      }, {}, new_img)
    }
  </div>

App.Chess.next_player(board: App.Chess.Board): Bits
    let last_bit = Bits.slice(1, board[4] <> Bits.e)
    log(Bits.show(last_bit))
    last_bit

App.Chess.is_move_possible(x0: Nat, y0: Nat, x1: Nat, y1: Nat, team: Bits, board: App.Chess.Board): Bool
  let origin_tile          = App.Chess.get(x0, y0, board)
  let to_tile              = App.Chess.get(x1, y1, board)
  let player               = App.Chess.next_player(board)
  let is_origin_tile_empty = Bits.eql(origin_tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
  if is_origin_tile_empty then
    false
  else
    let piece_owner       = Bits.slice(1, origin_tile)
    let is_piece_owner    = Bits.eql(piece_owner, team)
    let is_user_turn      = Bits.eql(piece_owner, player)
    let is_to_tile_empty  = Bits.eql(to_tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
    let is_to_tile_player = Bits.eql(Bits.slice(1, to_tile), team) 
    let pawn   = Bits.i(Bits.o(Bits.o(Bits.e)))
    let rook   = Bits.o(Bits.i(Bits.o(Bits.e)))
    let knight = Bits.i(Bits.i(Bits.o(Bits.e)))
    let bishop = Bits.o(Bits.o(Bits.i(Bits.e)))
    let queen  = Bits.i(Bits.o(Bits.i(Bits.e)))
    let king   = Bits.o(Bits.i(Bits.i(Bits.e)))

    if (is_user_turn && is_piece_owner) && (is_to_tile_empty || Bool.not(is_to_tile_player)) then
      switch Bits.eql(Bits.drop(1, origin_tile)) {
        pawn:   
          App.Chess.is_move_possible_pawn(x0, y0, x1, y1, is_to_tile_empty, piece_owner, board) ||
          App.Chess.is_move_possible_en_passant(x0, y0, x1, y1, is_to_tile_empty, piece_owner, board)
        rook:   
          App.Chess.is_move_possible_line(x0, y0, x1, y1, origin_tile, board)
        knight: 
          App.Chess.is_move_possible_knight(Nat.to_int(x0), Nat.to_int(y0), Nat.to_int(x1), Nat.to_int(y1), board)
        bishop: 
          App.Chess.is_move_possible_line(x0, y0, x1, y1, origin_tile, board)
        queen:  
          App.Chess.is_move_possible_line(x0, y0, x1, y1, origin_tile, board)
        king:   
          App.Chess.is_move_possible_king(Nat.to_int(x0), Nat.to_int(y0), Nat.to_int(x1), Nat.to_int(y1), board) ||
          App.Chess.is_castle_possible(x0, y0, x1, y1, board)
        
      } default false
    else
      false

App.Chess.is_castle_possible(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  let empty_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))) 
  let get_tile = (x: Nat, y: Nat) App.Chess.get(x, y, board)
  let king_tile = get_tile(x0, y0)
  let black_l = 
      Nat.eql(x0, 4) 
      && Nat.eql(y0, 0) 
      && Bits.eql(Bits.i(Bits.e), Bits.slice(1, king_tile))
      && Bits.eql(empty_tile, get_tile(3, 0))
      && Bits.eql(empty_tile, get_tile(2, 0))
      && Bits.eql(empty_tile, get_tile(1, 0))
      && Nat.eql(x1, 2) 
      && Nat.eql(y1, 0) 
      && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(1, board[4] <> Bits.e)))
      && Bool.not(App.Chess.is_checked(3, 0, board))
 
  let black_r =
    Nat.eql(x0, 4) 
    && Nat.eql(y0, 0) 
    && Bits.eql(Bits.i(Bits.e), Bits.slice(1, king_tile))
    && Bits.eql(empty_tile, get_tile(5, 0))
    && Bits.eql(empty_tile, get_tile(6, 0))
    && Nat.eql(x1, 6) 
    && Nat.eql(y1, 0) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(2, board[4] <> Bits.e)))
    && Bool.not(App.Chess.is_checked(5, 0, board))
  
  let white_l =
    Nat.eql(x0, 4) 
    && Nat.eql(y0, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, king_tile)) 
    && Bits.eql(empty_tile, get_tile(3, 7))
    && Bits.eql(empty_tile, get_tile(2, 7))
    && Bits.eql(empty_tile, get_tile(1, 7))
    && Nat.eql(x1, 2) 
    && Nat.eql(y1, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(3, board[4] <> Bits.e)))
    && Bool.not(App.Chess.is_checked(3, 7, board))
    
  let white_r =
    Nat.eql(x0, 4) 
    && Nat.eql(y0, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, king_tile)) 
    && Bits.eql(empty_tile, get_tile(5, 7))
    && Bits.eql(empty_tile, get_tile(6, 7))
    && Nat.eql(x1, 6) 
    && Nat.eql(y1, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(4, board[4] <> Bits.e)))
    && Bool.not(App.Chess.is_checked(5, 7, board))

  black_l || black_r || white_l || white_r


App.Chess.is_move_possible_en_passant(x0: Nat, y0: Nat, x1: Nat, y1: Nat, is_to_tile_empty: Bool, piece_owner: Bits, board: App.Chess.Board) : Bool
  if Bits.eql(piece_owner, Bits.o(Bits.e)) then
    is_to_tile_empty 
    && Nat.eql(y0, 3)
    && Nat.eql(y1, 2) 
    && (Nat.eql(x0 - x1, 1) || Nat.eql(x1 - x0, 1))
    && Nat.eql(Bits.to_nat(Bits.slice(4, Bits.drop(8, board[4] <> Bits.e))) - 1, x1)
  else
    is_to_tile_empty 
    && Nat.eql(y0, 4)
    && Nat.eql(y1, 5) 
    && (Nat.eql(x0 - x1, 1) || Nat.eql(x1 - x0, 1))
    && Nat.eql(Bits.to_nat(Bits.slice(4, Bits.drop(8, board[4] <> Bits.e))) - 1, x1)

App.Chess.is_move_possible_pawn(x0: Nat, y0: Nat, x1: Nat, y1: Nat, is_to_tile_empty: Bool, piece_owner: Bits, board: App.Chess.Board) : Bool
  if Bits.eql(piece_owner, Bits.o(Bits.e)) then
    if is_to_tile_empty then 
      if Nat.eql(y0, 6) then 
        Nat.eql(x0, x1) && (Nat.eql((y0 - y1), 1) || (Nat.eql((y0 - y1), 2) && Bits.eql(App.Chess.get(x0, y0 - 1, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))))
      else
        Nat.eql(x0, x1) && Nat.eql((y0 - y1), 1)
    else
      (Nat.eql(x0 - x1, 1) || Nat.eql(x1 - x0, 1)) && Nat.eql((y0 - y1), 1)
  else 
    if is_to_tile_empty then
      if Nat.eql(y0, 1) then
        Nat.eql(x0, x1) && (Nat.eql((y1 - y0), 1) || (Nat.eql((y1 - y0), 2) && Bits.eql(App.Chess.get(x0, y0 + 1, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))))
      else
        Nat.eql(x0, x1) && Nat.eql((y1 - y0), 1)
    else
      (Nat.eql(x1 - x0, 1) || Nat.eql(x0 - x1, 1)) && Nat.eql((y1 - y0), 1)
    

App.Chess.is_move_possible_line(x0: Nat, y0: Nat, x1: Nat, y1: Nat, origin_tile: Bits, board: App.Chess.Board): Bool
  let rook   = Bits.o(Bits.i(Bits.o(Bits.e)))
  let bishop = Bits.o(Bits.o(Bits.i(Bits.e)))
  let queen  = Bits.i(Bits.o(Bits.i(Bits.e)))
  let get_f  = (a: Nat, b: Nat) App.Chess.get_f(a, b) 
  
  let test  = 
    switch Bits.eql(Bits.drop(1, origin_tile)) {
      rook: 
        (Nat.eql(x0, x1) || Nat.eql(y0, y1)) 
      bishop:
        Nat.eql(Int.abs(Nat.to_int(x0) - Nat.to_int(x1)), Int.abs(Nat.to_int(y0) - Nat.to_int(y1))) 
      queen:
        true
    } default false 
  
  if test then
    App.Chess.Board.line_recursive(x0, y0, x1, y1, get_f(x0, x1), get_f(y0, y1), board)
  else 
    false

App.Chess.get_f(a: Nat, b: Nat): Nat -> Nat
  (nat)
  case Nat.cmp(a,b) {
    ltn: Nat.add(nat, 1)
    eql: nat
    gtn: Nat.sub(nat, 1)
  }

App.Chess.Board.line_recursive(
x0: Nat, y0: Nat           // From
x1: Nat, y1: Nat           // To
x_f: Nat -> Nat            // X Variation
y_f: Nat -> Nat            // Y Variation
board: App.Chess.Board     // Board
): Bool 
  let x = x_f(x0)
  let y = y_f(y0)
  let tile = App.Chess.get(x, y, board)
  let empty_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  if (x =? x1) && (y =? y1) then
    true
  else  
    if Bits.eql(tile, empty_tile) then
      App.Chess.Board.line_recursive(x, y, x1, y1, x_f, y_f, board)
    else
      false


App.Chess.is_move_possible_knight(x0: Int, y0: Int, x1: Int, y1: Int, board: App.Chess.Board): Bool
  (Nat.eql(Int.abs(x0 - x1), 2) && Nat.eql(Int.abs(y0 - y1), 1)) || (Nat.eql(Int.abs(x0 - x1), 1) && Nat.eql(Int.abs(y0 - y1), 2))


App.Chess.is_move_possible_king(x0: Int, y0: Int, x1: Int, y1: Int, board: App.Chess.Board): Bool
  Nat.lte(Int.abs(x0 - x1), 1) && Nat.lte(Int.abs(y0 - y1), 1)


App.Chess.move(code: Bits, board: App.Chess.Board): Maybe<App.Chess.Board>
  let team = Bits.slice(1,code)
  let x0   = Bits.slice(3,Bits.drop(1,code))
  let y0   = Bits.slice(3,Bits.drop(4,code))
  let x1   = Bits.slice(3,Bits.drop(7,code))
  let y1   = Bits.slice(3,Bits.drop(10,code))
  let is_possible = App.Chess.is_move_possible(Bits.to_nat(x0), Bits.to_nat(y0), Bits.to_nat(x1), Bits.to_nat(y1), team, board)
  if is_possible then     
    let new_board = App.Chess.move.aux(Bits.to_nat(x0), Bits.to_nat(y0), Bits.to_nat(x1), Bits.to_nat(y1), team, board)      
    let still_check =  App.Chess.in_check(team, new_board)
    if still_check then 
      none
    else 
      some(new_board)
  else
    none
  

App.Chess.move.aux(x0: Nat, y0: Nat, x1: Nat, y1: Nat, team: Bits, board: App.Chess.Board): App.Chess.Board
  let tile_size  = 4 :: Nat
  let from_index = (x0 * tile_size) + (y0 * 8 * tile_size)
  let from_chunk = App.Chess.get_chunk(from_index, board) 
  let from_tile  = Bits.slice(4, Bits.drop(56 - from_index % 60, from_chunk))
  let new_tile   = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  let from_chunk = Bits.set(56 - from_index % 60, new_tile, from_chunk)
  let new_board = 
    if from_index <? 60 then
        board[0] <- from_chunk 
      else if from_index <? 120 then  
        board[1] <- from_chunk
      else if from_index <? 180 then
        board[2] <- from_chunk
      else if from_index <? 240 then
        board[3] <- from_chunk
      else
        board[4] <- from_chunk

  // Pawn Promotion
  let from_tile =
    if Bits.eql(from_tile, Bits.i(Bits.i(Bits.o(Bits.o(Bits.e))))) && Nat.eql(y1, 7) then
      Bits.i(Bits.i(Bits.o(Bits.i(Bits.e))))
    else
      if Bits.eql(from_tile, Bits.o(Bits.i(Bits.o(Bits.o(Bits.e))))) && Nat.eql(y1, 0) then
        Bits.o(Bits.i(Bits.o(Bits.i(Bits.e))))
      else
        from_tile

  let is_en_passant_possible = App.Chess.is_en_passant_possible(x0, x1, y1, from_chunk, from_tile, new_board)


  let to_index = (x1 * tile_size) + (y1 * 8 * tile_size)
  let to_chunk = App.Chess.get_chunk(to_index, new_board)
  let to_chunk = Bits.set(56 - to_index % 60, from_tile, to_chunk)
  let new_board = 
    if to_index <? 60 then
        new_board[0] <- to_chunk 
      else if to_index <? 120 then  
        new_board[1] <- to_chunk
      else if to_index <? 180 then
        new_board[2] <- to_chunk
      else if to_index <? 240 then
        new_board[3] <- to_chunk
      else
        new_board[4] <- to_chunk


  let set_en_passant = App.Chess.set_en_passant(x0, y0, y1, from_tile)

  let new_board =
    if is_en_passant_possible then
      App.Chess.move.aux_en_passant(x0, y0, x1, y1, new_board)
    else
      new_board

  let last_chunk = new_board[4] <> Bits.e
  let last_chunk = Bits.set(8, set_en_passant, last_chunk) 
  let new_board = new_board[4] <- last_chunk
   

  let new_board = App.Chess.castle(x1, y1, new_board)

  let new_board = App.Chess.set_castle_bits(x0, y0, new_board)

  let next_player = Bits.not(App.Chess.next_player(new_board))
  let last_chunk  = Bits.set(0, next_player, new_board[4] <> Bits.e)  
  let new_board   = new_board[4] <- last_chunk 
  
  new_board         
 
  // log(List.show!(Bits.show, new_board)) 
  // log(Bool.show(App.Chess.is_castle_possible(4, 0, 2, 0, board)))
  // log(Bool.show(App.Chess.is_castle_possible(4, 0, 6, 0, board)))
  // log(Bool.show(App.Chess.is_castle_possible(4, 7, 2, 7, board)))
  // log(Bool.show(App.Chess.is_castle_possible(4, 7, 6, 7, board)))

App.Chess.set_en_passant(x0: Nat, y0: Nat, y1: Nat, from_tile: Bits): Bits
    if (Bits.eql(from_tile, Bits.i(Bits.i(Bits.o(Bits.o(Bits.e))))) && Nat.eql(y0, 1) && Nat.eql(y1, 3))
    || (Bits.eql(from_tile, Bits.o(Bits.i(Bits.o(Bits.o(Bits.e))))) && Nat.eql(y0, 6) && Nat.eql(y1, 4)) then
      log(Bits.show(Bits.trim(4, Nat.to_bits(x0 + 1))))
      log(Nat.show(Bits.to_nat(Bits.trim(4, Nat.to_bits(x0 + 1)))))
      Bits.trim(4, (Nat.to_bits(x0 + 1)))
    else    
      Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))

App.Chess.is_en_passant_possible(x0: Nat, x1: Nat, y1: Nat, from_chunk: Bits, from_tile: Bits, new_board: App.Chess.Board): Bool                 
    let to_index = (x1 * 4) + (y1 * 8 * 4)
    let to_chunk = App.Chess.get_chunk(to_index, new_board)
    let to_tile = Bits.slice(4, Bits.drop(56 - to_index % 60, to_chunk))
    log(List.show!(Bool.show, [
    Bits.eql(Bits.drop(1, from_tile), (Bits.i(Bits.o(Bits.o(Bits.e)))))
    (Nat.eql(x0 - x1, 1) || Nat.eql(x1 - x0, 1))
    Bits.eql(to_tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
  ]))
    Bits.eql(Bits.drop(1, from_tile), (Bits.i(Bits.o(Bits.o(Bits.e)))))
    && (Nat.eql(x0 - x1, 1) || Nat.eql(x1 - x0, 1))
    && Bits.eql(to_tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))

App.Chess.move.aux_en_passant(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): App.Chess.Board
  let index = (x1 * 4) + (y0 * 8 * 4)
  log(Nat.show(index))
  log(Nat.show(x1) | ", " | Nat.show(y0))
  let chunk = App.Chess.get_chunk(index, board) 
  log(Bits.show(chunk))
  let new_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  let chunk = Bits.set(56 - index % 60, new_tile, chunk)
  log(Bits.show(chunk))
  let new_board = 
    if index <? 60 then
        board[0] <- chunk 
      else if index <? 120 then  
        board[1] <- chunk
      else if index <? 180 then
        board[2] <- chunk
      else if index <? 240 then
        board[3] <- chunk
      else
        board[4] <- chunk
  new_board


App.Chess.in_check(team: Bits, board: App.Chess.Board): Bool
  let white_king = Bits.o(Bits.o(Bits.i(Bits.i(Bits.e))))
  let {xw, yw} = App.Chess.find_piece(white_king, board) <> Pair.new!!<8,8>

  let black_king = Bits.i(Bits.o(Bits.i(Bits.i(Bits.e))))
  let {xb, yb} = App.Chess.find_piece(black_king, board) <> Pair.new!!<8,8>
    
  if Bits.eql(Bits.o(Bits.e), team) then
    App.Chess.is_checked(xw, yw, board)
  else
    App.Chess.is_checked(xb, yb, board)

App.Chess.castle_move_rook(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): App.Chess.Board
  let tile_size  = 4 :: Nat
  let from_index = (x0 * tile_size) + (y0 * 8 * tile_size)
  let from_chunk = App.Chess.get_chunk(from_index, board) 
  let from_tile = Bits.slice(4, Bits.drop(56 - from_index % 60, from_chunk))
  let new_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  let from_chunk = Bits.set(56 - from_index % 60, new_tile, from_chunk)
  let new_board = 
    if from_index <? 60 then
        board[0] <- from_chunk 
      else if from_index <? 120 then  
        board[1] <- from_chunk
      else if from_index <? 180 then
        board[2] <- from_chunk
      else if from_index <? 240 then
        board[3] <- from_chunk
      else
        board[4] <- from_chunk

  let to_index = (x1 * tile_size) + (y1 * 8 * tile_size)
  let to_chunk = App.Chess.get_chunk(to_index, new_board)
  let to_chunk = Bits.set(56 - to_index % 60, from_tile, to_chunk)
  let new_board = 
    if to_index <? 60 then
        new_board[0] <- to_chunk 
      else if to_index <? 120 then  
        new_board[1] <- to_chunk
      else if to_index <? 180 then
        new_board[2] <- to_chunk
      else if to_index <? 240 then
        new_board[3] <- to_chunk
      else
        new_board[4] <- to_chunk
  new_board

App.Chess.castle(x1: Nat, y1: Nat, board: App.Chess.Board): App.Chess.Board
  let piece         = App.Chess.get(x1, y1, board)
  let piece1        = App.Chess.get(0, 0, board)
  let piece2        = App.Chess.get(7, 0, board)
  let piece3        = App.Chess.get(0, 7, board)
  let piece4        = App.Chess.get(7, 7, board)
  let black_rook    = Bits.i(Bits.o(Bits.i(Bits.o(Bits.e))))
  let white_rook    = Bits.o(Bits.o(Bits.i(Bits.o(Bits.e))))
  let is_black_king = Bits.eql(piece, Bits.i(Bits.o(Bits.i(Bits.i(Bits.e)))))
  let is_white_king = Bits.eql(piece, Bits.o(Bits.o(Bits.i(Bits.i(Bits.e)))))
  let is_possible   = (i: Nat) Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(i, board[4] <> Bits.e)))
  // log(Bits.show(piece))
  if is_black_king then
    if Nat.eql(x1, 2) && Nat.eql(y1, 0) && is_possible(1) && Bits.eql(piece1, black_rook) then
      App.Chess.castle_move_rook(0, 0, 3, 0, board)
    else  
      if Nat.eql(x1, 6) && Nat.eql(y1, 0) && is_possible(2) && Bits.eql(piece2, black_rook) then
        App.Chess.castle_move_rook(7, 0, 5, 0, board)
      else 
        board
  else
    if is_white_king then
      if Nat.eql(x1, 2) && Nat.eql(y1, 7) && is_possible(3) && Bits.eql(piece3, white_rook) then
        App.Chess.castle_move_rook(0, 7, 3, 7, board)
      else  
        if Nat.eql(x1, 6) && Nat.eql(y1, 7) && is_possible(4) && Bits.eql(piece4, white_rook) then
          App.Chess.castle_move_rook(7, 7, 5, 7, board)
        else 
          board 
    else
      board

App.Chess.set_castle_bits(x0: Nat, y0: Nat, board: App.Chess.Board): App.Chess.Board  
  if Nat.eql(x0, 4) && Nat.eql(y0, 0) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(1, Bits.i(Bits.e), last_chunk.value)
          let last_chunk = Bits.set(2, Bits.i(Bits.e), last_chunk)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 4) && Nat.eql(y0, 7) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(3, Bits.i(Bits.e), last_chunk.value)
          let last_chunk = Bits.set(4, Bits.i(Bits.e), last_chunk)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 0) && Nat.eql(y0, 0) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(1, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 7) && Nat.eql(y0, 0) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(2, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 0) && Nat.eql(y0, 7) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(3, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 7) && Nat.eql(y0, 7) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(4, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board
  else
    board

App.Chess.find_piece(piece: Bits, board: App.Chess.Board) : Maybe<Pair<Nat, Nat>>
  App.Chess.find_piece_aux(0, piece, board)

App.Chess.find_piece_aux(index: Nat, piece: Bits, board: App.Chess.Board) : Maybe<Pair<Nat, Nat>>
  let x = (index / 4) % 8
  let y = index / 32
  if Nat.gtn(index, 256) then 
    none
  else
    if Bits.eql(App.Chess.get(x, y, board), piece) then
      some(Pair.new!!(x, y))
  else
    App.Chess.find_piece_aux(index + 4, piece, board)

App.Chess.is_checked(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let line     = App.Chess.is_checked_line(x0, y0, board) 
  let diagonal = App.Chess.is_checked_diagonal(x0, y0, board) 
  let knight   = App.Chess.is_checked_knight(x0, y0, board)
  let pawn     = App.Chess.is_checked_pawn(x0, y0, board)
  let king     = App.Chess.is_checked_king(x0, y0, board)
  line || diagonal || knight || pawn || king 

App.Chess.is_checked_line(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let id    = (a: Int) a 
  let add   = (a: Int) Int.add(a, 1)
  let sub   = (a: Int) Int.sub(a, 1)
  let x1    = Nat.to_int(x0)
  let y1    = Nat.to_int(y0)
  let up    = App.Chess.is_checked_line_aux(x0, y0, x1, y1 - 1, id, sub, board)
  let down  = App.Chess.is_checked_line_aux(x0, y0, x1, y1 + 1, id, add, board)
  let left  = App.Chess.is_checked_line_aux(x0, y0, x1 - 1, y1, sub, id, board)
  let right = App.Chess.is_checked_line_aux(x0, y0, x1 + 1, y1, add, id, board)
  up || down || left || right

App.Chess.is_checked_line_aux(x0: Nat, y0: Nat, x1: Int, y1: Int, fx: Int -> Int, fy: Int -> Int, board: App.Chess.Board): Bool 
  if Int.ltn(y1, 0) || Int.gtn(y1, 7) || Int.ltn(x1, 0) || Int.gtn(x1, 7) then
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_checked_line_aux(x0, y0, fx(x1), fy(y1),fx, fy, board)
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.o(Bits.i(Bits.e))))
        || Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.o(Bits.i(Bits.o(Bits.e))))


App.Chess.is_checked_diagonal(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let add = (a: Int) Int.add(a, 1)
  let sub = (a: Int) Int.sub(a, 1)
  let x1  = Nat.to_int(x0)
  let y1  = Nat.to_int(y0)
  let q1  = App.Chess.is_checked_diagonal_aux(x0, y0, x1 + 1, y1 - 1, add, sub, board) 
  let q2  = App.Chess.is_checked_diagonal_aux(x0, y0, x1 - 1, y1 - 1, sub, sub, board) 
  let q3  = App.Chess.is_checked_diagonal_aux(x0, y0, x1 - 1, y1 + 1, sub, add, board) 
  let q4  = App.Chess.is_checked_diagonal_aux(x0, y0, x1 + 1, y1 + 1, add, add, board) 
  q1 || q2 || q3 || q4

App.Chess.is_checked_diagonal_aux(x0: Nat, y0: Nat, x1: Int, y1: Int, fx: Int -> Int, fy:  Int -> Int, board: App.Chess.Board): Bool
  let tile = App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)
  if Int.ltn(x1, 0) || Int.ltn(y1, 0) || Int.gtn(x1, 7) || Int.gtn(y1, 7) then
    false      
  else
    if Bits.eql(tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_checked_diagonal_aux(x0, y0, fx(x1), fy(y1), fx, fy, board)
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, tile)) then
        false
      else
        Bits.eql(Bits.drop(1, tile), Bits.o(Bits.o(Bits.i(Bits.e))))
        || Bits.eql(Bits.drop(1, tile), Bits.i(Bits.o(Bits.i(Bits.e))))

App.Chess.is_checked_knight(x0: Nat, y0: Nat, board: App.Chess.Board): Bool 
  let x1 = Nat.to_int(x0)
  let y1 = Nat.to_int(y0)
  let aux1 = App.Chess.is_checked_knight_aux(x0, y0, x1 + 1, y1 + 2, board)
  let aux2 = App.Chess.is_checked_knight_aux(x0, y0, x1 + 1, y1 - 2, board)
  let aux3 = App.Chess.is_checked_knight_aux(x0, y0, x1 - 1, y1 + 2, board)
  let aux4 = App.Chess.is_checked_knight_aux(x0, y0, x1 - 1, y1 - 2, board)
  let aux5 = App.Chess.is_checked_knight_aux(x0, y0, x1 + 2, y1 + 1, board)
  let aux6 = App.Chess.is_checked_knight_aux(x0, y0, x1 + 2, y1 - 1, board)
  let aux7 = App.Chess.is_checked_knight_aux(x0, y0, x1 - 2, y1 + 1, board)
  let aux8 = App.Chess.is_checked_knight_aux(x0, y0, x1 - 2, y1 - 1, board)
  aux1 || aux2 || aux3 || aux4 || aux5 || aux6 || aux7 || aux8

App.Chess.is_checked_knight_aux(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
    false
  else 
    if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
      false
    else
      Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.i(Bits.o(Bits.e))))

App.Chess.is_checked_pawn(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.o(Bits.e)) then
    App.Chess.is_checked_pawn_white(x0, y0, board)
  else
    App.Chess.is_checked_pawn_black(x0, y0, board)

App.Chess.is_checked_pawn_white(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let tile1 = App.Chess.get(x0 - 1, y0 - 1, board)
  let tile2 = App.Chess.get(x0 + 1, y0 - 1, board)
  let black_pawn = Bits.i(Bits.i(Bits.o(Bits.o(Bits.e))))
  Bits.eql(tile1, black_pawn) || Bits.eql(tile2, black_pawn)

App.Chess.is_checked_pawn_black(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let tile1 = App.Chess.get(x0 - 1, y0 + 1, board)
  let tile2 = App.Chess.get(x0 + 1, y0 + 1, board)
  let white_pawn = Bits.o(Bits.i(Bits.o(Bits.o(Bits.e))))
  Bits.eql(tile1, white_pawn) || Bits.eql(tile2, white_pawn)

App.Chess.is_checked_king(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let team     = Bits.slice(1, App.Chess.get(x0, y0, board))
  let get_tile = (x: Int, y: Int) App.Chess.get(Int.to_nat(x), Int.to_nat(y), board)
  let king     = Bits.concat(Bits.not(team), Bits.o(Bits.i(Bits.i(Bits.e))))
  let x = Nat.to_int(x0)
  let y = Nat.to_int(y0)

  Bits.eql(get_tile(x - 1, y - 1), king) ||
  Bits.eql(get_tile(x    , y - 1), king) ||
  Bits.eql(get_tile(x + 1, y - 1), king) ||
  Bits.eql(get_tile(x - 1, y    ), king) ||
  Bits.eql(get_tile(x + 1, y    ), king) ||
  Bits.eql(get_tile(x - 1, y + 1), king) ||
  Bits.eql(get_tile(x    , y + 1), king) ||
  Bits.eql(get_tile(x + 1, y + 1), king) 

App.Chess.mouse_to_coord(mouse_pos: Pair<U32, U32>): Pair<Nat, Nat>
  let scale     = App.Chess.scale
  let tile_size = App.Chess.tile_size
  let x = mouse_pos@fst / (scale * tile_size)
  let y = mouse_pos@snd / (scale * tile_size)
  {U32.to_nat(x), U32.to_nat(y)}

// Event handler
App.Chess.when: App.When<App.Chess.State>
  (event, state)
  let local = state@local
  let global = state@global
  let room = String.take(16, Crypto.Keccak.hash(App.Chess.room))
  case event {
    init: App.watch!(room)     
    

    mouse_down:
      let selected = local@selected
      let coord = App.Chess.mouse_to_coord(local@mouse_pos)
      case selected {
        none:
          open coord
            let local = local@selected <- some(coord)
            App.set_local!(local)
        some: 
          let {x0, y0} = selected.value
          let {x1, y1} = coord
          let team = local@team
          let team = without team: App.Chess.next_player(global) team
          let f = (x: Nat) Bits.trim(3, Nat.to_bits(x))
          let code = Bits.concat(team, Bits.concat(f(x0), Bits.concat(f(y0), Bits.concat(f(x1), f(y1))))) 
          let new_board = App.Chess.move(code, global)
          case new_board{
            none: App.set_local!(local@selected <- none)
            some:             
              let code = Bits.show(code)
              let team = Bits.not(team)
              IO {
                App.new_post!(room, code)
                let local = local@selected <- none             
                let local = local@team <- some(team)                              
                App.set_local!(local)          
            }
          } 
      } 
    mouse_move:
      let local = local@mouse_pos <- event.mouse_pos
      App.set_local!(local)
    
    key_down:
      log(List.show!((board) Bits.show_reverse(board) |"\n", global))
      App.pass!
  } default App.pass!


// Global ticker 
App.Chess.tick: App.Tick<App.Chess.State>
  App.no_tick<App.Chess.State>

App.Chess.post: App.Post<App.Chess.State>
  (time, room, addr, data, glob)
  let code = Bits.read(data)
  // App.Chess.move(code, glob)
  log(Bits.show_reverse(code))
  case code {    
    o: 
      let new_board = App.Chess.move(code.pred, glob)      
      case new_board{
        none: glob
        some: new_board.value
      }
  } default glob
  
App.Chess: App<App.Chess.State>
  let img = VoxBox.alloc_capacity(65536*8)
  App.new<App.Chess.State>(
    App.Chess.init
    App.Chess.draw(img)
    App.Chess.when
    App.Chess.tick
    App.Chess.post
  )