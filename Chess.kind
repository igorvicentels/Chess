App.Chess.State: App.State
  App.State.new(App.Chess.State.Local, App.Chess.Board)

type App.Chess.State.Local {
  new(
    mouse_pos: Pair<U32, U32>
    selected:  Maybe<Pair<Nat, Nat>>
    team:      Maybe<Bits>
  )
}

App.Chess.Board: Type
  List<Bits>

App.Chess.room: String
  "Chess_Room_410"

App.Chess.scale: U32
  2

App.Chess.tile_size: U32
  64#32


// 010101111001101111011001011101010011001100110011001100110011
// 001100000000000000000000000000000000000000000000000000000000
// 000000000000000000000000000000000000000000000000000000000000
// 000000000000001000100010001000100010001000100100011010001010
// 110010000110010000000000000000000000000000000000000000000000
//                                   27                       15                            9                5            1
// 110010000110010000000000000000000 000000000000(last move)  000000(turns without capture) 0000(en passant) 0000(castle) 0(team)

// empty        -> 0000
// black pawn   -> 0011
// black rook   -> 0101
// black knight -> 0111
// black bishop -> 1001
// black queen  -> 1011
// black king   -> 1101
// white pawn   -> 0010
// white rook   -> 0100
// white knight -> 0110
// white bishop -> 1000
// white queen  -> 1010
// white king   -> 1100
 
// Initial state
App.Chess.init: App.Init<App.Chess.State>
  let turn = 0 // TODO
  let mouse_pos = {0#32 0#32}
  let selected  = none
  let team      = none
  let chunk0    = Bits.trim(60, Nat.to_bits(394554900005204787))
  let chunk1    = Bits.trim(60, Nat.to_bits(216172782113783808))
  let chunk2    = Bits.trim(60, Nat.to_bits(0))
  let chunk3    = Bits.trim(60, Nat.to_bits(37529996904074))
  let chunk4    = Bits.trim(60, Nat.to_bits(902479144078540800))
  let local     = App.Chess.State.Local.new(mouse_pos, selected, team)
  let global    = [chunk0, chunk1, chunk2, chunk3, chunk4]
  App.Store.new<App.Chess.State>(local, global)

// Returns the chunk where the index is
App.Chess.get_chunk(index: Nat, board: App.Chess.Board): Bits
  let chunk = 
    if index <? 60 then
      board[0] <> Bits.e
    else if index <? 120 then  
      board[1] <> Bits.e
    else if index <? 180 then
      board[2] <> Bits.e
    else if index <? 240 then
      board[3] <> Bits.e
    else
      board[4] <> Bits.e
  chunk

// Returns the (x,y) tile
App.Chess.get(x: Nat, y: Nat, board: App.Chess.Board): Maybe<Bits>
  if Nat.gtn(x, 7) || Nat.gtn(y, 7) then
    none
  else
    let tile_size = 4 :: Nat
    let index = (x * tile_size) + (y * 8 * tile_size)
    let chunk = App.Chess.get_chunk(index, board)
    let tile = Bits.slice(tile_size, Bits.drop(56 - index % 60, chunk))
    some(tile)
      

App.Chess.canvas(local: App.Chess.State.Local, board: App.Chess.Board, img: VoxBox): VoxBox
  let size = App.Chess.tile_size
  for i from 0 to 64 with img:
    let x = i % 8
    let y = i / 8
    let is_black_tile = Nat.odd(x + y)
    let draw = VoxBox.Draw.image(((Nat.to_u32(x) * size) - 128) + size / 2, ((Nat.to_u32(y) * size) - 128) + size / 2)
    let draw_tile = VoxBox.Draw.rect(Nat.to_u32(x) * size, Nat.to_u32(y) * size, 0, 64, 64)
    let img = if not(is_black_tile) then draw_tile(Col32.new(100,100,100,255), img) else draw_tile(Col32.new(255,255,255,255), img)
    let tile = App.Chess.get(x, y, board) <> Bits.e
    switch Bits.eql(tile) {
      Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))): img
      Bits.o(Bits.i(Bits.o(Bits.o(Bits.e)))): draw(2, App.Chess.whitepawn, img)
      Bits.o(Bits.o(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.whiterook, img)
      Bits.o(Bits.i(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.whiteknight, img)
      Bits.o(Bits.o(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.whitebishop, img)
      Bits.o(Bits.i(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.whitequeen, img)
      Bits.o(Bits.o(Bits.i(Bits.i(Bits.e)))): draw(2, App.Chess.whiteking, img)
      Bits.i(Bits.i(Bits.o(Bits.o(Bits.e)))): draw(2, App.Chess.blackpawn, img)
      Bits.i(Bits.o(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.blackrook, img)
      Bits.i(Bits.i(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.blackknight, img)
      Bits.i(Bits.o(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.blackbishop, img)
      Bits.i(Bits.i(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.blackqueen, img)
      Bits.i(Bits.o(Bits.i(Bits.i(Bits.e)))): draw(2, App.Chess.blackking, img)
    } default img
  let selected = local@selected   
  without selected: img
  let {x, y} = {Nat.to_u32(selected@fst), Nat.to_u32(selected@snd)}
  let draw_outline = VoxBox.Draw.rect(x * size, y * size, 0, 64, 64, Col32.new(100,100,100,100), img)
  draw_outline

// Render function
App.Chess.draw(img: VoxBox): App.Draw<App.Chess.State>
  (state)
  let local  = state@local
  let global = state@global
  // Updates canvas
  let new_img = App.Chess.canvas(local, global, img)
  <div>
    {
    DOM.vbox(
      {
        "id": "game_screen",
        "width": U32.show(App.Chess.tile_size * 8)
        "height": U32.show(App.Chess.tile_size * 8)
        "scale": U32.show(App.Chess.scale)
      }, {}, new_img)
    }
  </div>

App.Chess.next_player(board: App.Chess.Board): Bits
    let last_bit = Bits.slice(1, board[4] <> Bits.e)
    last_bit

App.Chess.is_move_possible(x0: Nat, y0: Nat, x1: Int, y1: Int, team: Bits, board: App.Chess.Board): Bool
  let origin_tile          = App.Chess.get(x0, y0, board) <> Bits.e
  let to_tile              = App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board) <> Bits.e
  let player               = App.Chess.next_player(board)
  let is_origin_tile_empty = Bits.eql(origin_tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
  if is_origin_tile_empty then
    false
  else      
    if Int.ltn(x1, 0) || Int.ltn(y1, 0) || Int.gtn(x1, 7) || Int.gtn(y1, 7) then
      false
    else
      let piece_owner       = Bits.slice(1, origin_tile)
      let is_piece_owner    = Bits.eql(piece_owner, team)
      let is_user_turn      = Bits.eql(piece_owner, player)
      let is_to_tile_empty  = Bits.eql(to_tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
      let is_to_tile_player = Bits.eql(Bits.slice(1, to_tile), team) 
      let pawn   = Bits.i(Bits.o(Bits.o(Bits.e)))
      let rook   = Bits.o(Bits.i(Bits.o(Bits.e)))
      let knight = Bits.i(Bits.i(Bits.o(Bits.e)))
      let bishop = Bits.o(Bits.o(Bits.i(Bits.e)))
      let queen  = Bits.i(Bits.o(Bits.i(Bits.e)))
      let king   = Bits.o(Bits.i(Bits.i(Bits.e)))

      // log(List.show!(Bool.show, [is_piece_owner, is_user_turn, (is_to_tile_empty || Bool.not(is_to_tile_player))]))

      if (is_user_turn && is_piece_owner) && (is_to_tile_empty || Bool.not(is_to_tile_player)) then
        let x1 = Int.to_nat(x1)
        let y1 = Int.to_nat(y1)
        switch Bits.eql(Bits.drop(1, origin_tile)) {
          pawn:   
            App.Chess.is_move_possible_pawn(x0, y0, x1, y1, is_to_tile_empty, piece_owner, board) ||
            App.Chess.is_move_possible_en_passant(x0, y0, x1, y1, is_to_tile_empty, piece_owner, board)
          rook:   
            App.Chess.is_move_possible_line(x0, y0, x1, y1, origin_tile, board)
          knight: 
            App.Chess.is_move_possible_knight(x0, y0, x1, y1, board)
          bishop: 
            App.Chess.is_move_possible_line(x0, y0, x1, y1, origin_tile, board)
          queen:  
            App.Chess.is_move_possible_line(x0, y0, x1, y1, origin_tile, board)
          king:   
            App.Chess.is_move_possible_king(x0, y0, x1, y1, board) ||
            App.Chess.is_castle_possible(x0, y0, x1, y1, board)
          
        } default false
      else
        false

App.Chess.is_castle_possible(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  let empty_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))) 
  let get_tile = (x: Nat, y: Nat) App.Chess.get(x, y, board) <> Bits.e
  let king_tile = get_tile(x0, y0)
  let black_l = 
      Nat.eql(x0, 4) 
      && Nat.eql(y0, 0) 
      && Bits.eql(Bits.i(Bits.e), Bits.slice(1, king_tile))
      && Bits.eql(empty_tile, get_tile(3, 0))
      && Bits.eql(empty_tile, get_tile(2, 0))
      && Bits.eql(empty_tile, get_tile(1, 0))
      && Nat.eql(x1, 2) 
      && Nat.eql(y1, 0) 
      && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(1, board[4] <> Bits.e)))
      && Maybe.is_none!(App.Chess.is_attacked(3, 0, board))
 
  let black_r =
    Nat.eql(x0, 4) 
    && Nat.eql(y0, 0) 
    && Bits.eql(Bits.i(Bits.e), Bits.slice(1, king_tile))
    && Bits.eql(empty_tile, get_tile(5, 0))
    && Bits.eql(empty_tile, get_tile(6, 0))
    && Nat.eql(x1, 6) 
    && Nat.eql(y1, 0) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(2, board[4] <> Bits.e)))
    && Maybe.is_none!(App.Chess.is_attacked(5, 0, board))
  
  let white_l =
    Nat.eql(x0, 4) 
    && Nat.eql(y0, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, king_tile)) 
    && Bits.eql(empty_tile, get_tile(3, 7))
    && Bits.eql(empty_tile, get_tile(2, 7))
    && Bits.eql(empty_tile, get_tile(1, 7))
    && Nat.eql(x1, 2) 
    && Nat.eql(y1, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(3, board[4] <> Bits.e)))
    && Maybe.is_none!(App.Chess.is_attacked(3, 7, board))
    
  let white_r =
    Nat.eql(x0, 4) 
    && Nat.eql(y0, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, king_tile)) 
    && Bits.eql(empty_tile, get_tile(5, 7))
    && Bits.eql(empty_tile, get_tile(6, 7))
    && Nat.eql(x1, 6) 
    && Nat.eql(y1, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(4, board[4] <> Bits.e)))
    && Maybe.is_none!(App.Chess.is_attacked(5, 7, board))

  black_l || black_r || white_l || white_r


App.Chess.is_move_possible_en_passant(x0: Nat, y0: Nat, x1: Nat, y1: Nat, is_to_tile_empty: Bool, piece_owner: Bits, board: App.Chess.Board) : Bool
  if Bits.eql(piece_owner, Bits.o(Bits.e)) then
    is_to_tile_empty 
    && Nat.eql(y0, 3)
    && Nat.eql(y1, 2) 
    && (Nat.eql(x0 - x1, 1) || Nat.eql(x1 - x0, 1))
    && Nat.eql(Bits.to_nat(Bits.slice(4, Bits.drop(5, board[4] <> Bits.e))) - 1, x1)
  else
    is_to_tile_empty 
    && Nat.eql(y0, 4)
    && Nat.eql(y1, 5) 
    && (Nat.eql(x0 - x1, 1) || Nat.eql(x1 - x0, 1))
    && Nat.eql(Bits.to_nat(Bits.slice(4, Bits.drop(5, board[4] <> Bits.e))) - 1, x1)

App.Chess.is_move_possible_pawn(x0: Nat, y0: Nat, x1: Nat, y1: Nat, is_to_tile_empty: Bool, piece_owner: Bits, board: App.Chess.Board) : Bool
  if Bits.eql(piece_owner, Bits.o(Bits.e)) then
    if is_to_tile_empty then 
      if Nat.eql(y0, 6) then 
        Nat.eql(x0, x1) && (Nat.eql((y0 - y1), 1) || (Nat.eql((y0 - y1), 2) && Bits.eql(App.Chess.get(x0, y0 - 1, board) <> Bits.e, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))))
      else
        Nat.eql(x0, x1) && Nat.eql((y0 - y1), 1)
    else
      (Nat.eql(x0 - x1, 1) || Nat.eql(x1 - x0, 1)) && Nat.eql((y0 - y1), 1)
  else 
    if is_to_tile_empty then
      if Nat.eql(y0, 1) then
        Nat.eql(x0, x1) && (Nat.eql((y1 - y0), 1) || (Nat.eql((y1 - y0), 2) && Bits.eql(App.Chess.get(x0, y0 + 1, board) <> Bits.e, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))))
      else
        Nat.eql(x0, x1) && Nat.eql((y1 - y0), 1)
    else
      (Nat.eql(x1 - x0, 1) || Nat.eql(x0 - x1, 1)) && Nat.eql((y1 - y0), 1)
    

App.Chess.is_move_possible_line(x0: Nat, y0: Nat, x1: Nat, y1: Nat, origin_tile: Bits, board: App.Chess.Board): Bool
  let rook   = Bits.o(Bits.i(Bits.o(Bits.e)))
  let bishop = Bits.o(Bits.o(Bits.i(Bits.e)))
  let queen  = Bits.i(Bits.o(Bits.i(Bits.e)))
  let get_f  = (a: Nat, b: Nat) App.Chess.get_f(a, b) 
  
  let test  = 
    switch Bits.eql(Bits.drop(1, origin_tile)) {
      rook: 
        (Nat.eql(x0, x1) || Nat.eql(y0, y1)) 
      bishop:
        Nat.eql(Int.abs(Nat.to_int(x0) - Nat.to_int(x1)), Int.abs(Nat.to_int(y0) - Nat.to_int(y1))) 
      queen:
        true
    } default false 
  
  if test then
    App.Chess.Board.line_recursive(x0, y0, x1, y1, get_f(x0, x1), get_f(y0, y1), board)
  else 
    false

App.Chess.get_f(a: Nat, b: Nat): Nat -> Nat
  (nat)
  case Nat.cmp(a,b) {
    ltn: Nat.add(nat, 1)
    eql: nat
    gtn: Nat.sub(nat, 1)
  }

App.Chess.Board.line_recursive(
x0: Nat, y0: Nat           // From
x1: Nat, y1: Nat           // To
x_f: Nat -> Nat            // X Variation
y_f: Nat -> Nat            // Y Variation
board: App.Chess.Board     // Board
): Bool 
  let x = x_f(x0)
  let y = y_f(y0)
  let tile = App.Chess.get(x, y, board) <> Bits.e
  let empty_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  if (x =? x1) && (y =? y1) then
    true
  else  
    if Bits.eql(tile, empty_tile) then
      App.Chess.Board.line_recursive(x, y, x1, y1, x_f, y_f, board)
    else
      false


App.Chess.is_move_possible_knight(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  let x0 = Nat.to_int(x0)
  let y0 = Nat.to_int(y0)
  let x1 = Nat.to_int(x1)
  let y1 = Nat.to_int(y1)
  (Nat.eql(Int.abs(x0 - x1), 2) && Nat.eql(Int.abs(y0 - y1), 1)) || (Nat.eql(Int.abs(x0 - x1), 1) && Nat.eql(Int.abs(y0 - y1), 2))


App.Chess.is_move_possible_king(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  let x0 = Nat.to_int(x0)
  let y0 = Nat.to_int(y0)
  let x1 = Nat.to_int(x1)
  let y1 = Nat.to_int(y1)  
  Nat.lte(Int.abs(x0 - x1), 1) && Nat.lte(Int.abs(y0 - y1), 1)

App.Chess.is_checkmate(board: App.Chess.Board): Bool
  let team       = App.Chess.next_player(board)
  let in_check   = App.Chess.in_check(team, board)
  
  case in_check{ 
    some:
      let king =
        if Bits.eql(team, Bits.o(Bits.e)) then
            Bits.o(Bits.o(Bits.i(Bits.i(Bits.e))))
        else
            Bits.i(Bits.o(Bits.i(Bits.i(Bits.e))))

      let {xk, yk} = App.Chess.find_piece(king, board) <> {8, 8}
      let king_n  = 
        App.Chess.is_checkmate.king_move(xk, yk, Nat.to_int(xk), Nat.to_int(yk) - 1, team, board)
        log("n: " | Bool.show(king_n))

      let king_s  =
        App.Chess.is_checkmate.king_move(xk, yk, Nat.to_int(xk), Nat.to_int(yk) + 1, team, board)
        log("s: " | Bool.show(king_s))

      let king_e  = 
        App.Chess.is_checkmate.king_move(xk, yk, Nat.to_int(xk) + 1, Nat.to_int(yk), team, board)
        log("e: " | Bool.show(king_e))

      let king_w  = 
        App.Chess.is_checkmate.king_move(xk, yk, Nat.to_int(xk) - 1, Nat.to_int(yk), team, board)
        log("w: " | Bool.show(king_w))

      let king_ne = 
        App.Chess.is_checkmate.king_move(xk, yk, Nat.to_int(xk) + 1, Nat.to_int(yk) - 1, team, board)
        log("ne: " | Bool.show(king_ne))

      let king_nw = 
        App.Chess.is_checkmate.king_move(xk, yk, Nat.to_int(xk) - 1, Nat.to_int(yk) - 1, team, board)
        log("nw: " | Bool.show(king_nw))

      let king_se = 
        App.Chess.is_checkmate.king_move(xk, yk, Nat.to_int(xk) + 1, Nat.to_int(yk) + 1, team, board)
        log("se: " | Bool.show(king_se))

      let king_sw = 
        App.Chess.is_checkmate.king_move(xk, yk, Nat.to_int(xk) - 1, Nat.to_int(yk) + 1, team, board)
        log("sw: " | Bool.show(king_sw))

      let cant_move_king = king_n && king_s && king_e && king_w && king_ne && king_nw && king_se && king_sw
      
      let can_capture_attacker = 
        let attacker_pos = in_check.value
        let x = Bits.to_nat(Bits.trim(3, Bits.slice(3, attacker_pos)))
        let y = Bits.to_nat(Bits.trim(3, Bits.drop(3, attacker_pos)))                       
        let is_attacked = App.Chess.is_attacked(x, y, board)
        case is_attacked{
          some:
            let attacker_pos = is_attacked.value            
            let x0 = Bits.to_nat(Bits.slice(3, attacker_pos))
            let y0 = Bits.to_nat(Bits.drop(3, attacker_pos))            
            let move = App.Chess.move.aux(x0, y0, x, y, team, board)
            let still_check = Maybe.is_some!(App.Chess.in_check(team, move)) 
            Bool.not(still_check)
          none:
            false
        }
      log("capture_attacker: " | Bool.show(can_capture_attacker))

      let double_check =
        let x0 =  Bits.to_nat(Bits.slice(3,Bits.drop(15, board[4] <> Bits.e)))
        let y0 =  Bits.to_nat(Bits.slice(3,Bits.drop(18, board[4] <> Bits.e)))
        let x1 =  Bits.to_nat(Bits.slice(3,Bits.drop(21, board[4] <> Bits.e)))
        let y1 =  Bits.to_nat(Bits.slice(3,Bits.drop(24, board[4] <> Bits.e)))
        
        if x1 =? xk then 
          if y0 =? y1 then
          Maybe.is_some!(App.Chess.is_attacked_diagonal(xk, yk, team, board))
          else
            let id    = (a: Int) a 
            let add   = (a: Int) Int.add(a, 1)
            let sub   = (a: Int) Int.sub(a, 1)
            let xk1    = Nat.to_int(xk)
            let yk1    = Nat.to_int(yk)
            let left  = Maybe.is_some!(App.Chess.is_attacked_line_aux(xk, yk, xk1 - 1, yk1, sub, id, team, board)) 
            let right = Maybe.is_some!(App.Chess.is_attacked_line_aux(xk, yk, xk1 + 1, yk1, add, id, team, board))
            left || right

        else 
          if y1 =? yk then
            if x0 =? x1 then 
              Maybe.is_some!(App.Chess.is_attacked_diagonal(xk, yk, team, board))
            else 
              let id    = (a: Int) a 
              let add   = (a: Int) Int.add(a, 1)
              let sub   = (a: Int) Int.sub(a, 1)
              let xk1    = Nat.to_int(xk)
              let yk1    = Nat.to_int(yk)
              let up    = Maybe.is_some!(App.Chess.is_attacked_line_aux(xk, yk, xk1, yk1 - 1, id, sub, team, board))
              let down  = Maybe.is_some!(App.Chess.is_attacked_line_aux(xk, yk, xk1, yk1 + 1, id, add, team, board))
              up || down
          else 
            if Nat.eql(Int.abs(Nat.to_int(xk) - Nat.to_int(x1)), Int.abs(Nat.to_int(yk) - Nat.to_int(y1))) then              
              Maybe.is_some!(App.Chess.is_attacked_line(xk, yk, team, board))
            else              
              Maybe.is_some!(App.Chess.is_attacked_line(xk, yk, team, board)) || Maybe.is_some!(App.Chess.is_attacked_diagonal(xk, yk, team, board))

      log("double_check: " | Bool.show(double_check))

      let can_block = 
        let attacker_pos = in_check.value
        let x = Bits.to_nat(Bits.slice(3, attacker_pos))
        let y = Bits.to_nat(Bits.drop(3, attacker_pos))        
        let get_f  = (a: Nat, b: Nat) App.Chess.get_f(a, b)
        let king_pos = Bits.concat(Bits.trim(3, Nat.to_bits(xk)), Bits.trim(3, Nat.to_bits(yk)))        
        let new_board = board
        let new_team = Bits.not(team)          
        let last_chunk  = Bits.set(0, new_team, new_board[4] <> Bits.e)
        let new_board   = new_board[4] <- last_chunk

        App.Chess.is_checkmate.aux(xk, yk, x, y, get_f(xk, x), get_f(yk, y), king_pos, new_board)
      log("block_attacker: " | Bool.show(can_block))

      if double_check then
        cant_move_king
      else
        cant_move_king && Bool.not(can_capture_attacker) && Bool.not(can_block)        
    none: false
  } 

App.Chess.is_checkmate.aux(x: Nat, y: Nat, x1: Nat, y1: Nat, fx: Nat -> Nat, fy: Nat -> Nat, king_pos: Bits, board: App.Chess.Board): Bool
    let x = fx(x)
    let y = fy(y)
    if Nat.ltn(x, 0) || Nat.gtn(x, 7) || Nat.ltn(y, 0) || Nat.gtn(y, 7) then
      false
    else
      if Nat.eql(x, x1) && Nat.eql(y, y1) then
        false
      else
        let is_attacked = App.Chess.is_attacked(x, y, board)  
        case is_attacked{
          none:           
            App.Chess.is_checkmate.aux(x, y, x1, y1, fx, fy, king_pos, board)
          some: 
            if Bits.eql(is_attacked.value, king_pos) then
              App.Chess.is_checkmate.aux(x, y, x1, y1, fx, fy, king_pos, board)
            else
              let team     = App.Chess.next_player(board)
              let attacker = is_attacked.value
              let xa = Bits.to_nat(Bits.trim(3, Bits.slice(3, attacker)))
              let ya = Bits.to_nat(Bits.trim(3, Bits.drop(3, attacker)))
              let move = App.Chess.move.aux(xa, ya, x, y, Bits.not(team), board)
              let still_check = Maybe.is_some!(App.Chess.in_check(Bits.not(team), move))            
              Bool.not(still_check)
        }

App.Chess.is_checkmate.king_move(x0: Nat, y0: Nat, x1: Int, y1: Int, team: Bits, board: App.Chess.Board): Bool
  if Int.ltn(x1, 0) || Int.ltn(y1, 0) then 
    true
  else
    let is_possible = App.Chess.is_move_possible(x0, y0, x1, y1, team, board)
    let move        = App.Chess.move.aux(x0, y0, Int.to_nat(x1), Int.to_nat(y1), team, board)
    let still_check = Maybe.is_some!(App.Chess.in_check(team, move))    
    Bool.not(is_possible) || still_check


App.Chess.move(code: Bits, board: App.Chess.Board): Maybe<App.Chess.Board>
  let team = Bits.slice(1,code)
  let x0   = Bits.slice(3,Bits.drop(1,code))
  let y0   = Bits.slice(3,Bits.drop(4,code))
  let x1   = Bits.slice(3,Bits.drop(7,code))
  let y1   = Bits.slice(3,Bits.drop(10,code))
  let is_possible = App.Chess.is_move_possible(Bits.to_nat(x0), Bits.to_nat(y0), Nat.to_int(Bits.to_nat(x1)), Nat.to_int(Bits.to_nat(y1)), team, board)
  if is_possible then 
    let new_board = App.Chess.move.aux(Bits.to_nat(x0), Bits.to_nat(y0), Bits.to_nat(x1), Bits.to_nat(y1), team, board)      
    let still_check =  Maybe.is_some!(App.Chess.in_check(team, new_board))    
    if still_check then 
      none
    else 
      some(new_board)
  else
    none
  

App.Chess.move.aux(x0: Nat, y0: Nat, x1: Nat, y1: Nat, team: Bits, board: App.Chess.Board): App.Chess.Board
  let tile_size  = 4 :: Nat
  let from_index = (x0 * tile_size) + (y0 * 8 * tile_size)
  let from_chunk = App.Chess.get_chunk(from_index, board) 
  let from_tile  = Bits.slice(4, Bits.drop(56 - from_index % 60, from_chunk))
  let new_tile   = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  let from_chunk = Bits.set(56 - from_index % 60, new_tile, from_chunk)
  let new_board = 
    if from_index <? 60 then
        board[0] <- from_chunk 
      else if from_index <? 120 then  
        board[1] <- from_chunk
      else if from_index <? 180 then
        board[2] <- from_chunk
      else if from_index <? 240 then
        board[3] <- from_chunk
      else
        board[4] <- from_chunk

  // Pawn Promotion
  let from_tile =
    if Bits.eql(from_tile, Bits.i(Bits.i(Bits.o(Bits.o(Bits.e))))) && Nat.eql(y1, 7) then
      Bits.i(Bits.i(Bits.o(Bits.i(Bits.e))))
    else
      if Bits.eql(from_tile, Bits.o(Bits.i(Bits.o(Bits.o(Bits.e))))) && Nat.eql(y1, 0) then
        Bits.o(Bits.i(Bits.o(Bits.i(Bits.e))))
      else
        from_tile

  let is_en_passant_possible = App.Chess.is_en_passant_possible(x0, x1, y1, from_chunk, from_tile, new_board)


  let to_index = (x1 * tile_size) + (y1 * 8 * tile_size)
  let to_chunk = App.Chess.get_chunk(to_index, new_board)
  let to_chunk = Bits.set(56 - to_index % 60, from_tile, to_chunk)
  let new_board = 
    if to_index <? 60 then
        new_board[0] <- to_chunk 
      else if to_index <? 120 then  
        new_board[1] <- to_chunk
      else if to_index <? 180 then
        new_board[2] <- to_chunk
      else if to_index <? 240 then
        new_board[3] <- to_chunk
      else
        new_board[4] <- to_chunk


  let set_en_passant = App.Chess.set_en_passant(x0, y0, y1, from_tile)

  let new_board =
    if is_en_passant_possible then
      App.Chess.move.aux_en_passant(x0, y0, x1, y1, new_board)
    else
      new_board

  let last_chunk = new_board[4] <> Bits.e
  let last_chunk = Bits.set(5, set_en_passant, last_chunk) 
  let new_board = new_board[4] <- last_chunk

  let new_board = App.Chess.castle(x1, y1, new_board)

  let new_board = App.Chess.set_castle_bits(x0, y0, new_board)

  let next_player = Bits.not(App.Chess.next_player(new_board))
  let last_chunk  = Bits.set(0, next_player, new_board[4] <> Bits.e)
  let last_move   = Bits.concat(Bits.trim(3, Nat.to_bits(x0)), Bits.concat(Bits.trim(3,Nat.to_bits(y0)), Bits.concat(Bits.trim(3, Nat.to_bits(x1)), Bits.trim(3,Nat.to_bits(y1)))))
  let last_chunk  = Bits.set(15, last_move, last_chunk)
  let new_board   = new_board[4] <- last_chunk 
  
  new_board         


App.Chess.set_en_passant(x0: Nat, y0: Nat, y1: Nat, from_tile: Bits): Bits
    if (Bits.eql(from_tile, Bits.i(Bits.i(Bits.o(Bits.o(Bits.e))))) && Nat.eql(y0, 1) && Nat.eql(y1, 3))
    || (Bits.eql(from_tile, Bits.o(Bits.i(Bits.o(Bits.o(Bits.e))))) && Nat.eql(y0, 6) && Nat.eql(y1, 4)) then
      Bits.trim(4, (Nat.to_bits(x0 + 1)))
    else    
      Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))

App.Chess.is_en_passant_possible(x0: Nat, x1: Nat, y1: Nat, from_chunk: Bits, from_tile: Bits, new_board: App.Chess.Board): Bool                 
    let to_index = (x1 * 4) + (y1 * 8 * 4)
    let to_chunk = App.Chess.get_chunk(to_index, new_board)
    let to_tile = Bits.slice(4, Bits.drop(56 - to_index % 60, to_chunk))
    Bits.eql(Bits.drop(1, from_tile), (Bits.i(Bits.o(Bits.o(Bits.e)))))
    && (Nat.eql(x0 - x1, 1) || Nat.eql(x1 - x0, 1))
    && Bits.eql(to_tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))

App.Chess.move.aux_en_passant(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): App.Chess.Board
  let index = (x1 * 4) + (y0 * 8 * 4)
  let chunk = App.Chess.get_chunk(index, board) 
  let new_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  let chunk = Bits.set(56 - index % 60, new_tile, chunk)
  let new_board = 
    if index <? 60 then
        board[0] <- chunk 
      else if index <? 120 then  
        board[1] <- chunk
      else if index <? 180 then
        board[2] <- chunk
      else if index <? 240 then
        board[3] <- chunk
      else
        board[4] <- chunk
  new_board


App.Chess.in_check(team: Bits, board: App.Chess.Board): Maybe<Bits>
  let white_king = Bits.o(Bits.o(Bits.i(Bits.i(Bits.e))))
  let {xw, yw} = App.Chess.find_piece(white_king, board) <> Pair.new!!<8,8>

  let black_king = Bits.i(Bits.o(Bits.i(Bits.i(Bits.e))))
  let {xb, yb} = App.Chess.find_piece(black_king, board) <> Pair.new!!<8,8>
    
  if Bits.eql(Bits.o(Bits.e), team) then
    App.Chess.is_attacked(xw, yw, board)
  else
    App.Chess.is_attacked(xb, yb, board)

App.Chess.castle_move_rook(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): App.Chess.Board
  let tile_size  = 4 :: Nat
  let from_index = (x0 * tile_size) + (y0 * 8 * tile_size)
  let from_chunk = App.Chess.get_chunk(from_index, board) 
  let from_tile = Bits.slice(4, Bits.drop(56 - from_index % 60, from_chunk))
  let new_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  let from_chunk = Bits.set(56 - from_index % 60, new_tile, from_chunk)
  let new_board = 
    if from_index <? 60 then
        board[0] <- from_chunk 
      else if from_index <? 120 then  
        board[1] <- from_chunk
      else if from_index <? 180 then
        board[2] <- from_chunk
      else if from_index <? 240 then
        board[3] <- from_chunk
      else
        board[4] <- from_chunk

  let to_index = (x1 * tile_size) + (y1 * 8 * tile_size)
  let to_chunk = App.Chess.get_chunk(to_index, new_board)
  let to_chunk = Bits.set(56 - to_index % 60, from_tile, to_chunk)
  let new_board = 
    if to_index <? 60 then
        new_board[0] <- to_chunk 
      else if to_index <? 120 then  
        new_board[1] <- to_chunk
      else if to_index <? 180 then
        new_board[2] <- to_chunk
      else if to_index <? 240 then
        new_board[3] <- to_chunk
      else
        new_board[4] <- to_chunk
  new_board

App.Chess.castle(x1: Nat, y1: Nat, board: App.Chess.Board): App.Chess.Board
  let piece         = App.Chess.get(x1, y1, board) <> Bits.e
  let piece1        = App.Chess.get(0, 0, board) <> Bits.e
  let piece2        = App.Chess.get(7, 0, board) <> Bits.e
  let piece3        = App.Chess.get(0, 7, board) <> Bits.e
  let piece4        = App.Chess.get(7, 7, board) <> Bits.e
  let black_rook    = Bits.i(Bits.o(Bits.i(Bits.o(Bits.e))))
  let white_rook    = Bits.o(Bits.o(Bits.i(Bits.o(Bits.e))))
  let is_black_king = Bits.eql(piece, Bits.i(Bits.o(Bits.i(Bits.i(Bits.e)))))
  let is_white_king = Bits.eql(piece, Bits.o(Bits.o(Bits.i(Bits.i(Bits.e)))))
  let is_possible   = (i: Nat) Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(i, board[4] <> Bits.e)))
  if is_black_king then
    if Nat.eql(x1, 2) && Nat.eql(y1, 0) && is_possible(1) && Bits.eql(piece1, black_rook) then
      App.Chess.castle_move_rook(0, 0, 3, 0, board)
    else  
      if Nat.eql(x1, 6) && Nat.eql(y1, 0) && is_possible(2) && Bits.eql(piece2, black_rook) then
        App.Chess.castle_move_rook(7, 0, 5, 0, board)
      else 
        board
  else
    if is_white_king then
      if Nat.eql(x1, 2) && Nat.eql(y1, 7) && is_possible(3) && Bits.eql(piece3, white_rook) then
        App.Chess.castle_move_rook(0, 7, 3, 7, board)
      else  
        if Nat.eql(x1, 6) && Nat.eql(y1, 7) && is_possible(4) && Bits.eql(piece4, white_rook) then
          App.Chess.castle_move_rook(7, 7, 5, 7, board)
        else 
          board 
    else
      board

App.Chess.set_castle_bits(x0: Nat, y0: Nat, board: App.Chess.Board): App.Chess.Board  
  if Nat.eql(x0, 4) && Nat.eql(y0, 0) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(1, Bits.i(Bits.e), last_chunk.value)
          let last_chunk = Bits.set(2, Bits.i(Bits.e), last_chunk)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 4) && Nat.eql(y0, 7) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(3, Bits.i(Bits.e), last_chunk.value)
          let last_chunk = Bits.set(4, Bits.i(Bits.e), last_chunk)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 0) && Nat.eql(y0, 0) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(1, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 7) && Nat.eql(y0, 0) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(2, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 0) && Nat.eql(y0, 7) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(3, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 7) && Nat.eql(y0, 7) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(4, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board
  else
    board

App.Chess.find_piece(piece: Bits, board: App.Chess.Board) : Maybe<Pair<Nat, Nat>>
  App.Chess.find_piece_aux(0, piece, board)

App.Chess.find_piece_aux(index: Nat, piece: Bits, board: App.Chess.Board) : Maybe<Pair<Nat, Nat>>
  let x = (index / 4) % 8
  let y = index / 32
  if Nat.gtn(index, 256) then 
    none
  else
    if Bits.eql(App.Chess.get(x, y, board) <> Bits.e, piece) then
      some(Pair.new!!(x, y))
  else
    App.Chess.find_piece_aux(index + 4, piece, board)

App.Chess.is_attacked(x0: Nat, y0: Nat, board: App.Chess.Board): Maybe<Bits>
  let team = 
    if Bits.eql(Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))), App.Chess.get(x0, y0, board) <> Bits.e) then
      App.Chess.next_player(board)
    else
      (Bits.slice(1, App.Chess.get(x0, y0, board) <> Bits.e))

  let line     = App.Chess.is_attacked_line(x0, y0, team, board) 
  let diagonal = App.Chess.is_attacked_diagonal(x0, y0, team, board) 
  let knight   = App.Chess.is_attacked_knight(x0, y0, team, board) 
  let pawn     = App.Chess.is_attacked_pawn(x0, y0, team, board) 
  let king     = App.Chess.is_attacked_king(x0, y0, team, board) 
  
  switch Bool.eql(true){
    Maybe.is_some!(line):     line
    Maybe.is_some!(diagonal): diagonal
    Maybe.is_some!(knight):   knight
    Maybe.is_some!(pawn):     pawn
    Maybe.is_some!(king):     king
  } default none
  

App.Chess.is_attacked_line(x0: Nat, y0: Nat, team: Bits, board: App.Chess.Board): Maybe<Bits>
  let id    = (a: Int) a 
  let add   = (a: Int) Int.add(a, 1)
  let sub   = (a: Int) Int.sub(a, 1)
  let x1    = Nat.to_int(x0)
  let y1    = Nat.to_int(y0)
  let up    = App.Chess.is_attacked_line_aux(x0, y0, x1, y1 - 1, id, sub, team, board)
  let down  = App.Chess.is_attacked_line_aux(x0, y0, x1, y1 + 1, id, add, team, board)
  let left  = App.Chess.is_attacked_line_aux(x0, y0, x1 - 1, y1, sub, id, team, board)
  let right = App.Chess.is_attacked_line_aux(x0, y0, x1 + 1, y1, add, id, team, board)
  switch Bool.eql(true) {
    Maybe.is_some!(up):    up
    Maybe.is_some!(down):  down
    Maybe.is_some!(left):  left
    Maybe.is_some!(right): right
  } default none

App.Chess.is_attacked_line_aux(x0: Nat, y0: Nat, x1: Int, y1: Int, fx: Int -> Int, fy: Int -> Int, team: Bits board: App.Chess.Board): Maybe<Bits> 
  let tile = Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board) <> Bits.e)
  if Int.ltn(y1, 0) || Int.gtn(y1, 7) || Int.ltn(x1, 0) || Int.gtn(x1, 7) then
    none      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board) <> Bits.e, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_attacked_line_aux(x0, y0, fx(x1), fy(y1), fx, fy, team, board)
    else 
      if Bits.eql(team, Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board) <> Bits.e)) then
        none
       else
        let rook  = Bits.o(Bits.i(Bits.o(Bits.e)))
        let queen = Bits.i(Bits.o(Bits.i(Bits.e)))
        if Bits.eql(tile, queen) || Bits.eql(tile, rook) then
          some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x1))), Bits.trim(3, Nat.to_bits(Int.to_nat(y1)))))
        else
          none 

App.Chess.is_attacked_diagonal(x0: Nat, y0: Nat, team: Bits, board: App.Chess.Board): Maybe<Bits>
  let add = (a: Int) Int.add(a, 1)
  let sub = (a: Int) Int.sub(a, 1)
  let x1  = Nat.to_int(x0)
  let y1  = Nat.to_int(y0)
  let q1  = App.Chess.is_attacked_diagonal_aux(x0, y0, x1 + 1, y1 - 1, add, sub, team, board) 
  let q2  = App.Chess.is_attacked_diagonal_aux(x0, y0, x1 - 1, y1 - 1, sub, sub, team, board) 
  let q3  = App.Chess.is_attacked_diagonal_aux(x0, y0, x1 - 1, y1 + 1, sub, add, team, board) 
  let q4  = App.Chess.is_attacked_diagonal_aux(x0, y0, x1 + 1, y1 + 1, add, add, team, board) 
  switch Bool.eql(true) {
    Maybe.is_some!(q1): q1
    Maybe.is_some!(q2): q2
    Maybe.is_some!(q3): q3
    Maybe.is_some!(q4): q4
  } default none

App.Chess.is_attacked_diagonal_aux(x0: Nat, y0: Nat, x1: Int, y1: Int, fx: Int -> Int, fy:  Int -> Int, team: Bits, board: App.Chess.Board): Maybe<Bits>
  let tile = App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board) <> Bits.e
  if Int.ltn(x1, 0) || Int.ltn(y1, 0) || Int.gtn(x1, 7) || Int.gtn(y1, 7) then
    none      
  else
    if Bits.eql(tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_attacked_diagonal_aux(x0, y0, fx(x1), fy(y1), fx, fy, team, board)
    else 
      if Bits.eql(team, Bits.slice(1, tile)) then
        none
      else
        if Bits.eql(Bits.drop(1, tile), Bits.o(Bits.o(Bits.i(Bits.e))))
        || Bits.eql(Bits.drop(1, tile), Bits.i(Bits.o(Bits.i(Bits.e)))) then          
          some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x1))), Bits.trim(3, Nat.to_bits(Int.to_nat(y1)))))
        else
          none

App.Chess.is_attacked_knight(x0: Nat, y0: Nat, team: Bits, board: App.Chess.Board): Maybe<Bits>
  let x1 = Nat.to_int(x0)
  let y1 = Nat.to_int(y0)
  let aux1 = App.Chess.is_attacked_knight_aux(x0, y0, x1 + 1, y1 + 2, team, board)
  let aux2 = App.Chess.is_attacked_knight_aux(x0, y0, x1 + 1, y1 - 2, team, board)
  let aux3 = App.Chess.is_attacked_knight_aux(x0, y0, x1 - 1, y1 + 2, team, board)
  let aux4 = App.Chess.is_attacked_knight_aux(x0, y0, x1 - 1, y1 - 2, team, board)
  let aux5 = App.Chess.is_attacked_knight_aux(x0, y0, x1 + 2, y1 + 1, team, board)
  let aux6 = App.Chess.is_attacked_knight_aux(x0, y0, x1 + 2, y1 - 1, team, board)
  let aux7 = App.Chess.is_attacked_knight_aux(x0, y0, x1 - 2, y1 + 1, team, board)
  let aux8 = App.Chess.is_attacked_knight_aux(x0, y0, x1 - 2, y1 - 1, team, board)
  switch Bool.eql(true) {
    Maybe.is_some!(aux1): aux1
    Maybe.is_some!(aux2): aux2
    Maybe.is_some!(aux3): aux3
    Maybe.is_some!(aux4): aux4
    Maybe.is_some!(aux5): aux5
    Maybe.is_some!(aux6): aux6
    Maybe.is_some!(aux7): aux7
    Maybe.is_some!(aux8): aux8
  } default none

App.Chess.is_attacked_knight_aux(x0: Nat, y0: Nat, x1: Int, y1: Int, team: Bits, board: App.Chess.Board): Maybe<Bits>
    if Int.ltn(x1, 0) || Int.gtn(x1, 7) || Int.gtn(y1, 7) || Int.ltn(y1,0)then
    none
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board) <> Bits.e, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      none
    else 
      if Bits.eql(team, Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board) <> Bits.e)) then 
        none
    else
        if Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board) <> Bits.e), Bits.i(Bits.i(Bits.o(Bits.e)))) then
          some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x1))), Bits.trim(3, Nat.to_bits(Int.to_nat(y1)))))
        else
          none

App.Chess.is_attacked_pawn(x0: Nat, y0: Nat, team: Bits, board: App.Chess.Board): Maybe<Bits>
  let tile  = App.Chess.get(x0, y0, board) <> Bits.e
  let is_from_empty = Bits.eql(tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
  if is_from_empty then
    if Bits.eql(team, Bits.o(Bits.e)) then
      App.Chess.is_attacked_pawn_black(x0, y0, board)
    else
      App.Chess.is_attacked_pawn_white(x0, y0, board)
  else
    if Bits.eql(team, Bits.o(Bits.e)) then
      App.Chess.is_attacked_pawn_white(x0, y0, board)
    else
      App.Chess.is_attacked_pawn_black(x0, y0, board)

App.Chess.is_attacked_pawn_white(x0: Nat, y0: Nat, board: App.Chess.Board): Maybe<Bits>
  let tile  = App.Chess.get(x0, y0, board) <> Bits.e
  let is_from_empty = Bits.eql(tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
  if is_from_empty then
    if Nat.eql(y0, 4) &&
       Bits.eql(Bits.o(Bits.i(Bits.o(Bits.o(Bits.e)))), App.Chess.get(x0, y0 + 2, board) <> Bits.e) && 
       Bits.eql(Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))), App.Chess.get(x0, y0 + 1, board) <> Bits.e) then 
        some(Bits.concat(Bits.trim(3, Nat.to_bits(x0)), Bits.trim(3, Nat.to_bits(y0 + 2))))
    else
      if Bits.eql(Bits.o(Bits.i(Bits.o(Bits.o(Bits.e)))), App.Chess.get(x0, y0 + 1, board) <> Bits.e) then 
        some(Bits.concat(Bits.trim(3, Nat.to_bits(x0)), Bits.trim(3, Nat.to_bits(y0 + 1))))
      else
        none    
  else
    let tile1 = App.Chess.get(x0 - 1, y0 - 1, board) <> Bits.e
    let tile2 = App.Chess.get(x0 + 1, y0 - 1, board) <> Bits.e
    let black_pawn = Bits.i(Bits.i(Bits.o(Bits.o(Bits.e))))
    if Bits.eql(tile1, black_pawn) then
        some(Bits.concat(Bits.trim(3, Nat.to_bits(x0 - 1)), Bits.trim(3, Nat.to_bits(y0 - 1))))
    else 
        if Bits.eql(tile2, black_pawn) then
        some(Bits.concat(Bits.trim(3, Nat.to_bits(x0 + 1)), Bits.trim(3, Nat.to_bits(y0 - 1))))
        else
        none

App.Chess.is_attacked_pawn_black(x0: Nat, y0: Nat, board: App.Chess.Board): Maybe<Bits>
  let tile  = App.Chess.get(x0, y0, board) <> Bits.e
  let is_from_empty = Bits.eql(tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
  if is_from_empty then
    if Nat.eql(y0, 3) &&
       Bits.eql(Bits.i(Bits.i(Bits.o(Bits.o(Bits.e)))), App.Chess.get(x0, y0 - 2, board) <> Bits.e) && 
       Bits.eql(Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))), App.Chess.get(x0, y0 - 1, board) <> Bits.e) then 
        some(Bits.concat(Bits.trim(3, Nat.to_bits(x0)), Bits.trim(3, Nat.to_bits(y0 - 2))))
    else
      if Bits.eql(Bits.i(Bits.i(Bits.o(Bits.o(Bits.e)))), App.Chess.get(x0, y0 - 1, board) <> Bits.e) then 
        some(Bits.concat(Bits.trim(3, Nat.to_bits(x0)), Bits.trim(3, Nat.to_bits(y0 - 1))))
      else
        none    
  else
    let tile1 = App.Chess.get(x0 - 1, y0 + 1, board) <> Bits.e
    let tile2 = App.Chess.get(x0 + 1, y0 + 1, board) <> Bits.e
    let white_pawn = Bits.o(Bits.i(Bits.o(Bits.o(Bits.e))))
    if Bits.eql(tile1, white_pawn) then
      some(Bits.concat(Bits.trim(3, Nat.to_bits(x0 - 1)), Bits.trim(3, Nat.to_bits(y0 + 1))))
    else 
      if Bits.eql(tile2, white_pawn) then
        some(Bits.concat(Bits.trim(3, Nat.to_bits(x0 + 1)), Bits.trim(3,Nat.to_bits(y0 + 1))))
      else
        none

App.Chess.is_attacked_king(x0: Nat, y0: Nat, team: Bits, board: App.Chess.Board): Maybe<Bits>
  let get_tile = (x: Int, y: Int) App.Chess.get(Int.to_nat(x), Int.to_nat(y), board) <> Bits.e
  let king     = Bits.concat(Bits.not(team), Bits.o(Bits.i(Bits.i(Bits.e))))
  let x = Nat.to_int(x0)
  let y = Nat.to_int(y0)  

  switch Bool.eql(true) {
    Bits.eql(get_tile(x - 1, y - 1), king): some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x - 1))), Bits.trim(3, Nat.to_bits(Int.to_nat(y - 1)))))
    Bits.eql(get_tile(x    , y - 1), king): some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x))), Bits.trim(3, Nat.to_bits(Int.to_nat(y - 1)))))
    Bits.eql(get_tile(x + 1, y - 1), king): some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x + 1))), Bits.trim(3, Nat.to_bits(Int.to_nat(y - 1)))))
    Bits.eql(get_tile(x - 1, y    ), king): some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x - 1))), Bits.trim(3, Nat.to_bits(Int.to_nat(y)))))
    Bits.eql(get_tile(x + 1, y    ), king): some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x + 1))), Bits.trim(3, Nat.to_bits(Int.to_nat(y)))))
    Bits.eql(get_tile(x - 1, y + 1), king): some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x - 1))), Bits.trim(3, Nat.to_bits(Int.to_nat(y + 1)))))
    Bits.eql(get_tile(x    , y + 1), king): some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x))), Bits.trim(3, Nat.to_bits(Int.to_nat(y + 1)))))
    Bits.eql(get_tile(x + 1, y + 1), king): some(Bits.concat(Bits.trim(3, Nat.to_bits(Int.to_nat(x + 1))), Bits.trim(3, Nat.to_bits(Int.to_nat(y + 1))))) 
  } default none


App.Chess.is_stalemate(board: App.Chess.Board): Bool
  Bool.not(App.Chess.test_piece(board))

App.Chess.test_piece(board: App.Chess.Board): Bool
  App.Chess.test_piece.go(0, board)

App.Chess.test_piece.go(index: Nat, board: App.Chess.Board): Bool
  let team = App.Chess.next_player(board)
  let x = (index / 4) % 8
  let y = index / 32
  log("index: " | Nat.show(index))
  log("x: " | Nat.show(x) | "   y: " | Nat.show(y))
  let empty_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  let tile   = App.Chess.get(x, y, board) <> Bits.e
  let pawn   = Bits.i(Bits.o(Bits.o(Bits.e)))
  let rook   = Bits.o(Bits.i(Bits.o(Bits.e)))
  let knight = Bits.i(Bits.i(Bits.o(Bits.e)))
  let bishop = Bits.o(Bits.o(Bits.i(Bits.e)))
  let queen  = Bits.i(Bits.o(Bits.i(Bits.e)))
  let king   = Bits.o(Bits.i(Bits.i(Bits.e)))
  if Nat.gtn(index, 255) then 
    false
  else
    if Bits.eql(tile, empty_tile) || Bool.not(Bits.eql(Bits.slice(1, tile), team)) then
      log("empty or wrong team")
      App.Chess.test_piece.go(index + 4, board)
    else
      log("else")
      switch Bits.eql(Bits.drop(1, tile)) {
        pawn:   App.Chess.test_piece_pawn(index, board)
        rook:   App.Chess.test_piece_rook(index, board)
        knight: App.Chess.test_piece_knight(index, board)
        bishop: App.Chess.test_piece_bishop(index, board)
        queen:  App.Chess.test_piece_queen(index, board) // TODO: Check is it is better to just call the rook and bishop functions
        king: App.Chess.test_piece_king(index, board)
      } default  App.Chess.test_piece.go(index + 4, board)

App.Chess.test_piece_king(index: Nat, board: App.Chess.Board): Bool
  let team     = App.Chess.next_player(board)
  let king     = Bits.concat(team, Bits.o(Bits.i(Bits.i(Bits.e))))
  let {xk, yk} = App.Chess.find_piece(king, board) <> {8, 8}
  log("king pos - x: " | Nat.show(xk) | "   y: " | Nat.show(yk))
  let king_n   = 
    App.Chess.can_move_king(xk, yk, Nat.to_int(xk), Nat.to_int(yk) - 1, team, board)
    log("n: " | Bool.show(king_n))

  let king_s  =
    App.Chess.can_move_king(xk, yk, Nat.to_int(xk), Nat.to_int(yk) + 1, team, board)
    log("s: " | Bool.show(king_s))

  let king_e  = 
    App.Chess.can_move_king(xk, yk, Nat.to_int(xk) + 1, Nat.to_int(yk), team, board)
    log("e: " | Bool.show(king_e))

  let king_w  = 
    App.Chess.can_move_king(xk, yk, Nat.to_int(xk) - 1, Nat.to_int(yk), team, board)
    log("w: " | Bool.show(king_w))

  let king_ne = 
    App.Chess.can_move_king(xk, yk, Nat.to_int(xk) + 1, Nat.to_int(yk) - 1, team, board)
    log("ne: " | Bool.show(king_ne))

  let king_nw = 
    App.Chess.can_move_king(xk, yk, Nat.to_int(xk) - 1, Nat.to_int(yk) - 1, team, board)
    log("nw: " | Bool.show(king_nw))

  let king_se = 
    App.Chess.can_move_king(xk, yk, Nat.to_int(xk) + 1, Nat.to_int(yk) + 1, team, board)
    log("se: " | Bool.show(king_se))

  let king_sw = 
    App.Chess.can_move_king(xk, yk, Nat.to_int(xk) - 1, Nat.to_int(yk) + 1, team, board)
    log("sw: " | Bool.show(king_sw))
  
  let can_move = king_n || king_s || king_e || king_w || king_ne || king_nw || king_se || king_sw

  if can_move then true else App.Chess.test_piece.go(index + 4, board)


App.Chess.can_move_king(x0: Nat, y0: Nat, x1: Int, y1: Int, team: Bits, board: App.Chess.Board): Bool
  if Int.ltn(x1, 0) || Int.ltn(y1, 0) then 
    false
  else
    let is_possible = App.Chess.is_move_possible(x0, y0, x1, y1, team, board)
    let move        = App.Chess.move.aux(x0, y0, Int.to_nat(x1), Int.to_nat(y1), team, board)
    let still_check = Maybe.is_some!(App.Chess.in_check(team, move))    
    is_possible && Bool.not(still_check)


App.Chess.test_piece_pawn(index: Nat, board: App.Chess.Board): Bool
  let x    = (index / 4) % 8
  let y    = index / 32
  let team = App.Chess.next_player(board) // TODO: checar se Ã© melhor passar o team como parametro
  let pawn = App.Chess.get(x, y, board) <> Bits.e
  log("pawn")
  log("pos - x: " | Nat.show(x) | "   y: " | Nat.show(y)) 
  // TODO: Check if the is_possible need to be verified before the is_check
  let can_move = 
    let f = if Bits.eql(Bits.slice(1, pawn), Bits.o(Bits.e)) then Nat.sub else Nat.add
    log("teste: " | Nat.show(f(y,1)))
    log("teste: " | Nat.show(f(y,2)))
    let x1 = Nat.to_int(x)
    let is_possible1 = App.Chess.is_move_possible(x, y, x1    , Nat.to_int(f(y, 1)), team, board)
    let is_possible2 = App.Chess.is_move_possible(x, y, x1   , Nat.to_int(f(y, 2)), team, board)
    let is_possible3 = App.Chess.is_move_possible(x, y, x1 - 1, Nat.to_int(f(y, 1)), team, board)
    let is_possible4 = App.Chess.is_move_possible(x, y, x1 + 1, Nat.to_int(f(y, 1)), team, board)

    let is_check1 = 
      let move = App.Chess.move.aux(x, y, x, f(y, 1), team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    let is_check2 =
      let move = App.Chess.move.aux(x, y, x, f(y, 2), team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    let is_check3 = 
      let move = App.Chess.move.aux(x, y, x - 1, f(y, 1), team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    let is_check4 =
      let move = App.Chess.move.aux(x, y, x + 1, f(y, 1), team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))
    
    log("is_possible1 " | Bool.show(is_possible1 && Bool.not(is_check1)))
    log("is_possible2 " | Bool.show(is_possible2 && Bool.not(is_check2)))
    log("is_possible3 " | Bool.show(is_possible3 && Bool.not(is_check3)))
    log("is_possible4 " | Bool.show(is_possible4 && Bool.not(is_check4)))

    (is_possible1 && Bool.not(is_check1)) ||
    (is_possible2 && Bool.not(is_check2)) ||
    (is_possible3 && Bool.not(is_check3)) ||
    (is_possible4 && Bool.not(is_check4))
    
  if can_move then true else App.Chess.test_piece.go(index + 4, board)

App.Chess.test_piece_knight(index: Nat, board: App.Chess.Board): Bool
  let x    = (index / 4) % 8
  let y    = index / 32
  let team = App.Chess.next_player(board)
  log("knight")
  log("pos - x: " | Nat.show(x) | "   y: " | Nat.show(y))
  let x1 = Nat.to_int(x)
  let y1 = Nat.to_int(y)
  let can_move =
    let is_possible1 = App.Chess.is_move_possible(x, y, x1 + 2, y1 + 1, team, board)
    let is_possible2 = App.Chess.is_move_possible(x, y, x1 + 2, y1 - 1, team, board)
    let is_possible3 = App.Chess.is_move_possible(x, y, x1 - 2, y1 + 1, team, board)
    let is_possible4 = App.Chess.is_move_possible(x, y, x1 - 2, y1 - 1, team, board)
    let is_possible5 = App.Chess.is_move_possible(x, y, x1 + 1, y1 + 2, team, board)
    let is_possible6 = App.Chess.is_move_possible(x, y, x1 + 1, y1 - 2, team, board)
    let is_possible7 = App.Chess.is_move_possible(x, y, x1 - 1, y1 + 2, team, board)
    let is_possible8 = App.Chess.is_move_possible(x, y, x1 - 1, y1 - 2, team, board)

    let is_check1 =
      let move = App.Chess.move.aux(x, y, x + 2, y + 1, team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    let is_check2 =
      let move = App.Chess.move.aux(x, y, x + 2, y - 1, team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    let is_check3 =
      let move = App.Chess.move.aux(x, y, x - 2, y + 1, team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    let is_check4 =
      let move = App.Chess.move.aux(x, y, x - 2, y - 1, team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    let is_check5 =
      let move = App.Chess.move.aux(x, y, x + 1, y + 2, team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    let is_check6 =
      let move = App.Chess.move.aux(x, y, x + 1, y - 2, team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    let is_check7 =
      let move = App.Chess.move.aux(x, y, x - 1, y + 2, team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    let is_check8 =
      let move = App.Chess.move.aux(x, y, x - 1, y - 2, team, board)
      Maybe.is_some!(App.Chess.in_check(team, move))

    log("is_possible - x: " | Nat.show(x + 2) | "   y: " | Nat.show(y + 1)  | Bool.show(is_possible1 && Bool.not(is_check1)))
    log("is_possible - x: " | Nat.show(x + 2) | "   y: " | Nat.show(y - 1)  | Bool.show(is_possible2 && Bool.not(is_check2)))
    log("is_possible - x: " | Nat.show(x - 2) | "   y: " | Nat.show(y + 1)  | Bool.show(is_possible3 && Bool.not(is_check3)))
    log("is_possible - x: " | Nat.show(x - 2) | "   y: " | Nat.show(y - 1)  | Bool.show(is_possible4 && Bool.not(is_check4)))
    log("is_possible - x: " | Nat.show(x + 1) | "   y: " | Nat.show(y + 2)  | Bool.show(is_possible5 && Bool.not(is_check5)))
    log("is_possible - x: " | Nat.show(x + 1) | "   y: " | Nat.show(y - 2)  | Bool.show(is_possible6 && Bool.not(is_check6)))
    log("is_possible - x: " | Nat.show(x - 1) | "   y: " | Nat.show(y + 2)  | Bool.show(is_possible7 && Bool.not(is_check7)))
    log("is_possible - x: " | Nat.show(x - 1) | "   y: " | Nat.show(y - 2)  | Bool.show(is_possible8 && Bool.not(is_check8)))
    
    (is_possible1 && Bool.not(is_check1)) ||
    (is_possible2 && Bool.not(is_check2)) ||
    (is_possible3 && Bool.not(is_check3)) ||
    (is_possible4 && Bool.not(is_check4)) ||
    (is_possible5 && Bool.not(is_check5)) ||
    (is_possible6 && Bool.not(is_check6)) ||
    (is_possible7 && Bool.not(is_check7)) ||
    (is_possible8 && Bool.not(is_check8))

  if can_move then true else App.Chess.test_piece.go(index + 4, board)

App.Chess.test_piece_rook(index: Nat, board: App.Chess.Board): Bool
  let x    = (index / 4) % 8
  let y    = index / 32
  let team = App.Chess.next_player(board) // TODO: checar se Ã© melhor passar o team como parametro
  let rook = App.Chess.get(x, y, board) <> Bits.e
  let x = Nat.to_int(x)
  let y = Nat.to_int(y)
  log("rook")
  log("pos - x: " |Int.show(x) | "   y: " |Int.show(y))
  let add = (a: Int) Int.add(a, 1)
  let sub = (a: Int) Int.sub(a, 1)
  let id  = (a: Int) a
  let can_move =
    let up    = App.Chess.test_piece.recursive(x, y,  id, sub, team, board)
    let down  = App.Chess.test_piece.recursive(x, y,  id, add, team, board)
    let left  = App.Chess.test_piece.recursive(x, y, sub,  id, team, board)
    let right = App.Chess.test_piece.recursive(x, y, add,  id, team, board)
    log("up:    " | Bool.show(up))
    log("down:  " | Bool.show(down))
    log("left:  " | Bool.show(left))
    log("right: " | Bool.show(right))
    up || down || left || right

  if can_move then true else App.Chess.test_piece.go(index + 4, board)

App.Chess.test_piece_bishop(index: Nat, board: App.Chess.Board): Bool
  let x    = (index / 4) % 8
  let y    = index / 32
  let team = App.Chess.next_player(board) // TODO: checar se Ã© melhor passar o team como parametro
  let rook = App.Chess.get(x, y, board) <> Bits.e
  let x = Nat.to_int(x)
  let y = Nat.to_int(y)
  log("bishop")
  log("pos - x: " |Int.show(x) | "   y: " |Int.show(y))
  let add = (a: Int) Int.add(a, 1)
  let sub = (a: Int) Int.sub(a, 1)
  let can_move =
    let q1 = App.Chess.test_piece.recursive(x, y, add, sub, team, board)
    let q2 = App.Chess.test_piece.recursive(x, y, sub, sub, team, board)
    let q3 = App.Chess.test_piece.recursive(x, y, sub, add, team, board)
    let q4 = App.Chess.test_piece.recursive(x, y, add, add, team, board)
    log("q1: " | Bool.show(q1))
    log("q2: " | Bool.show(q2))
    log("q3: " | Bool.show(q3))
    log("q4: " | Bool.show(q4))
    q1 || q2 || q3 || q4

  if can_move then true else App.Chess.test_piece.go(index + 4, board)

  App.Chess.test_piece_queen(index: Nat, board: App.Chess.Board): Bool
  let x    = (index / 4) % 8
  let y    = index / 32
  let team = App.Chess.next_player(board) // TODO: checar se Ã© melhor passar o team como parametro
  let rook = App.Chess.get(x, y, board) <> Bits.e
  let x = Nat.to_int(x)
  let y = Nat.to_int(y)
  log("queen")
  log("pos - x: " |Int.show(x) | "   y: " |Int.show(y))
  let add = (a: Int) Int.add(a, 1)
  let sub = (a: Int) Int.sub(a, 1)
  let id  = (a: Int) a
  let can_move =
    let n  = App.Chess.test_piece.recursive(x, y, id , sub, team, board)
    let s  = App.Chess.test_piece.recursive(x, y, id , add, team, board)
    let e  = App.Chess.test_piece.recursive(x, y, add, id , team, board)
    let w  = App.Chess.test_piece.recursive(x, y, sub, id , team, board)
    let ne = App.Chess.test_piece.recursive(x, y, add, sub, team, board)
    let nw = App.Chess.test_piece.recursive(x, y, sub, add, team, board)
    let se = App.Chess.test_piece.recursive(x, y, add, add, team, board)
    let sw = App.Chess.test_piece.recursive(x, y, sub, add, team, board)
    log("n:  " | Bool.show(n))
    log("s:  " | Bool.show(s))
    log("e:  " | Bool.show(e))
    log("w:  " | Bool.show(w))
    log("ne: " | Bool.show(ne))
    log("nw: " | Bool.show(nw))
    log("se: " | Bool.show(se))
    log("sw: " | Bool.show(sw))
    n || s || e || w || ne || nw || se || sw

  if can_move then true else App.Chess.test_piece.go(index + 4, board)

App.Chess.test_piece.recursive(x: Int, y: Int, fx: Int -> Int, fy: Int -> Int, team: Bits, board: App.Chess.Board): Bool
  let x1 = fx(x)
  let y1 = fy(y) 
  if Int.ltn(x1, 0) || Int.ltn(y1, 0) || Int.gtn(x1, 7) || Int.gtn(y1, 7) then
    false
  else
    let is_possible = App.Chess.is_move_possible(Int.to_nat(x), Int.to_nat(y), x1, y1, team, board)
    if is_possible then
      let is_check = 
        let move = App.Chess.move.aux(Int.to_nat(x), Int.to_nat(y), Int.to_nat(x1), Int.to_nat(y1), team, board)
        Maybe.is_some!(App.Chess.in_check(team, move))
      if is_check then
        App.Chess.test_piece.recursive(x1, y1, fx, fy, team, board)
      else
        true
    else
      false

App.Chess.mouse_to_coord(mouse_pos: Pair<U32, U32>): Pair<Nat, Nat>
  let scale     = App.Chess.scale
  let tile_size = App.Chess.tile_size
  let x = mouse_pos@fst / (scale * tile_size)
  let y = mouse_pos@snd / (scale * tile_size)
  {U32.to_nat(x), U32.to_nat(y)}

// Event handler
App.Chess.when: App.When<App.Chess.State>
  (event, state)
  let local = state@local
  let global = state@global
  let room = String.take(16, Crypto.Keccak.hash(App.Chess.room))
  case event {
    init: App.watch!(room)

    mouse_down:
      let selected = local@selected
      let coord = App.Chess.mouse_to_coord(local@mouse_pos)
      case selected {
        none:
          open coord
            let local = local@selected <- some(coord)
            App.set_local!(local)
        some: 
          let {x0, y0} = selected.value
          let {x1, y1} = coord
          let team = local@team
          let team = without team: App.Chess.next_player(global) team
          let f = (x: Nat) Bits.trim(3, Nat.to_bits(x))
          let code = Bits.concat(team, Bits.concat(f(x0), Bits.concat(f(y0), Bits.concat(f(x1), f(y1))))) 
          let new_board = App.Chess.move(code, global)
          case new_board{
            none: App.set_local!(local@selected <- none)
            some:             
              let code = Bits.show(code)
              let team = Bits.not(team)
              IO {
                App.new_post!(room, code)
                let local = local@selected <- none             
                let local = local@team <- some(team)                              
                App.set_local!(local)          
            }
          } 
      } 
    mouse_move:
      let local = local@mouse_pos <- event.mouse_pos
      App.set_local!(local)
    
    key_down:
      log(List.show!((board) Bits.show_reverse(board) |"\n", global))
      let is_checkmate = App.Chess.is_checkmate(global)
      // let is_stalemate = App.Chess.is_stalemate(global)
      log("Checkmate: "|Bool.show(is_checkmate))
      // log("Stalemate: "|Bool.show(is_stalemate))
      log(Bits.show(global[4] <> Bits.e))
      App.pass!
  } default App.pass!


// Global ticker 
App.Chess.tick: App.Tick<App.Chess.State>
  App.no_tick<App.Chess.State>

App.Chess.post: App.Post<App.Chess.State>
  (time, room, addr, data, glob)
  let code = Bits.read(data)
  // App.Chess.move(code, glob)
  log(Bits.show_reverse(code))
  case code {    
    o: 
      let new_board = App.Chess.move(code.pred, glob)      
      case new_board{
        none: glob
        some: new_board.value
      }
  } default glob
  
App.Chess: App<App.Chess.State>
  let img = VoxBox.alloc_capacity(65536*8)
  App.new<App.Chess.State>(
    App.Chess.init
    App.Chess.draw(img)
    App.Chess.when
    App.Chess.tick
    App.Chess.post
  )