App.Chess.State: App.State
  App.State.new(App.Chess.State.Local, App.Chess.Board)

type App.Chess.State.Local {
  new(
    mouse_pos: Pair<U32, U32>
    selected:  Maybe<Pair<Nat, Nat>>
    team:      Bits
  )
}

App.Chess.Board: Type
  List<Bits>

App.Chess.room: String
  "Chess_Room_011"

App.Chess.scale: U32
  2

App.Chess.tile_size: U32
  64#32


// 010101111001101111011001011101010011001100110011001100110011
// 001100000000000000000000000000000000000000000000000000000000
// 000000000000000000000000000000000000000000000000000000000000
// 000000000000001000100010001000100010001000100100011010001010
// 110010000110010000000000000000000000000000000000000000000000

// empty        -> 0000
// black pawn   -> 0011
// black rook   -> 0101
// black knight -> 0111
// black bishop -> 1001
// black queen  -> 1011
// black king   -> 1101
// white pawn   -> 0010
// white rook   -> 0100
// white knight -> 0110
// white bishop -> 1000
// white queen  -> 1010
// white king   -> 1100
 
// Initial state
App.Chess.init: App.Init<App.Chess.State>
  let turn = 0 // TODO
  let mouse_pos = {0#32 0#32}
  let selected  = none
  let team      = Bits.o(Bits.e)
  let chunk0    = Bits.trim(60, Nat.to_bits(394554900005204787))
  let chunk1    = Bits.trim(60, Nat.to_bits(216172782113783808))
  let chunk2    = Bits.trim(60, Nat.to_bits(0))
  let chunk3    = Bits.trim(60, Nat.to_bits(37529996904074))
  let chunk4    = Bits.trim(60, Nat.to_bits(902479144078540800))
  let local     = App.Chess.State.Local.new(mouse_pos, selected, team)
  let global    = [chunk0, chunk1, chunk2, chunk3, chunk4]
  App.Store.new<App.Chess.State>(local, global)

// Returns the chunk where the index is
App.Chess.get_chunk(index: Nat, board: App.Chess.Board): Bits
  let chunk = 
    if index <? 60 then
      board[0] <> Bits.e
    else if index <? 120 then  
      board[1] <> Bits.e
    else if index <? 180 then
      board[2] <> Bits.e
    else if index <? 240 then
      board[3] <> Bits.e
    else
      board[4] <> Bits.e
  chunk

// Returns the (x,y) tile
App.Chess.get(x: Nat, y: Nat, board: App.Chess.Board): Bits
  let tile_size = 4 :: Nat
  let index = (x * tile_size) + (y * 8 * tile_size)
  let chunk = App.Chess.get_chunk(index, board)
  let tile = Bits.slice(tile_size, Bits.drop(56 - index % 60, chunk))
  tile
      

App.Chess.canvas(local: App.Chess.State.Local, board: App.Chess.Board, img: VoxBox): VoxBox
  let size = App.Chess.tile_size
  for i from 0 to 64 with img:
    let x = i % 8
    let y = i / 8
    let is_black_tile = Nat.odd(x + y)
    let draw = VoxBox.Draw.image(((Nat.to_u32(x) * size) - 128) + size / 2, ((Nat.to_u32(y) * size) - 128) + size / 2)
    let draw_tile = VoxBox.Draw.rect(Nat.to_u32(x) * size, Nat.to_u32(y) * size, 0, 64, 64)
    let img = if not(is_black_tile) then draw_tile(Col32.new(100,100,100,255), img) else draw_tile(Col32.new(255,255,255,255), img)
    let tile = App.Chess.get(x, y, board)
    switch Bits.eql(tile) {
      Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))): img
      Bits.o(Bits.i(Bits.o(Bits.o(Bits.e)))): draw(2, App.Chess.whitepawn, img)
      Bits.o(Bits.o(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.whiterook, img)
      Bits.o(Bits.i(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.whiteknight, img)
      Bits.o(Bits.o(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.whitebishop, img)
      Bits.o(Bits.i(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.whitequeen, img)
      Bits.o(Bits.o(Bits.i(Bits.i(Bits.e)))): draw(2, App.Chess.whiteking, img)
      Bits.i(Bits.i(Bits.o(Bits.o(Bits.e)))): draw(2, App.Chess.blackpawn, img)
      Bits.i(Bits.o(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.blackrook, img)
      Bits.i(Bits.i(Bits.i(Bits.o(Bits.e)))): draw(2, App.Chess.blackknight, img)
      Bits.i(Bits.o(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.blackbishop, img)
      Bits.i(Bits.i(Bits.o(Bits.i(Bits.e)))): draw(2, App.Chess.blackqueen, img)
      Bits.i(Bits.o(Bits.i(Bits.i(Bits.e)))): draw(2, App.Chess.blackking, img)
    } default img
  let selected = local@selected   
  without selected: img
  let {x, y} = {Nat.to_u32(selected@fst), Nat.to_u32(selected@snd)}
  let draw_outline = VoxBox.Draw.rect(x * size, y * size, 0, 64, 64, Col32.new(100,100,100,100), img)
  draw_outline

// Render function
App.Chess.draw(img: VoxBox): App.Draw<App.Chess.State>
  (state)
  let local  = state@local
  let global = state@global
  // Updates canvas
  let new_img = App.Chess.canvas(local, global, img)
  <div>
    {
    DOM.vbox(
      {
        "id": "game_screen",
        "width": U32.show(App.Chess.tile_size * 8)
        "height": U32.show(App.Chess.tile_size * 8)
        "scale": U32.show(App.Chess.scale)
      }, {}, new_img)
    }
  </div>

App.Chess.next_player(board: App.Chess.Board): Bits
    Bits.slice(1, board[4] <> Bits.e)

App.Chess.is_move_possible(x0: Nat, y0: Nat, x1: Nat, y1: Nat, team: Bits, board: App.Chess.Board): Bool
  let origin_tile          = App.Chess.get(x0, y0, board)
  let to_tile              = App.Chess.get(x1, y1, board)
  let player               = App.Chess.next_player(board)
  let is_origin_tile_empty = Bits.eql(origin_tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
  if is_origin_tile_empty then
    false
  else
    let piece_owner       = Bits.slice(1, origin_tile)
    let is_piece_owner    = Bits.eql(piece_owner, team)
    let is_user_turn      = Bits.eql(piece_owner, player)
    let is_to_tile_empty  = Bits.eql(to_tile, Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
    let is_to_tile_player = Bits.eql(Bits.slice(1, to_tile), team) 
    if is_piece_owner && (is_to_tile_empty || Bool.not(is_to_tile_player)) then
      switch Bits.eql(origin_tile) {
        Bits.o(Bits.i(Bits.o(Bits.o(Bits.e)))): App.Chess.is_move_possible_pawn(x0, y0, x1, y1, is_to_tile_empty, piece_owner, board)
        Bits.o(Bits.o(Bits.i(Bits.o(Bits.e)))): App.Chess.is_move_possible_rook(x0, y0, x1, y1, board)
        Bits.o(Bits.i(Bits.i(Bits.o(Bits.e)))): App.Chess.is_move_possible_knight(Nat.to_int(x0), Nat.to_int(y0), Nat.to_int(x1), Nat.to_int(y1), board)
        Bits.o(Bits.o(Bits.o(Bits.i(Bits.e)))): App.Chess.is_move_possible_bishop(Nat.to_int(x0), Nat.to_int(y0), Nat.to_int(x1), Nat.to_int(y1), board)
        Bits.o(Bits.i(Bits.o(Bits.i(Bits.e)))): App.Chess.is_move_possible_queen(x0, y0, x1, y1, board)
        Bits.o(Bits.o(Bits.i(Bits.i(Bits.e)))): App.Chess.is_move_possible_king(Nat.to_int(x0), Nat.to_int(y0), Nat.to_int(x1), Nat.to_int(y1), board)
                                                || App.Chess.is_castle_possible(x0, y0, x1, y1, board)
        Bits.i(Bits.i(Bits.o(Bits.o(Bits.e)))): App.Chess.is_move_possible_pawn(x0, y0, x1, y1, is_to_tile_empty, piece_owner, board)
        Bits.i(Bits.o(Bits.i(Bits.o(Bits.e)))): App.Chess.is_move_possible_rook(x0, y0, x1, y1, board)
        Bits.i(Bits.i(Bits.i(Bits.o(Bits.e)))): App.Chess.is_move_possible_knight(Nat.to_int(x0), Nat.to_int(y0), Nat.to_int(x1), Nat.to_int(y1), board)
        Bits.i(Bits.o(Bits.o(Bits.i(Bits.e)))): App.Chess.is_move_possible_bishop(Nat.to_int(x0), Nat.to_int(y0), Nat.to_int(x1), Nat.to_int(y1), board)
        Bits.i(Bits.i(Bits.o(Bits.i(Bits.e)))): App.Chess.is_move_possible_queen(x0, y0, x1, y1, board)
        Bits.i(Bits.o(Bits.i(Bits.i(Bits.e)))): App.Chess.is_move_possible_king(Nat.to_int(x0), Nat.to_int(y0), Nat.to_int(x1), Nat.to_int(y1), board)
                                                || App.Chess.is_castle_possible(x0, y0, x1, y1, board)
      } default false
    else
      false

App.Chess.is_castle_possible(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  let empty_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))) 
  let get_tile = (x: Nat, y: Nat) App.Chess.get(x, y, board)
  let king_tile = get_tile(x0, y0)
  let black_l = 
      Nat.eql(x0, 4) 
      && Nat.eql(y0, 0) 
      && Bits.eql(Bits.i(Bits.e), Bits.slice(1, king_tile))
      && Bits.eql(empty_tile, get_tile(3, 0))
      && Bits.eql(empty_tile, get_tile(2, 0))
      && Bits.eql(empty_tile, get_tile(1, 0))
      && Nat.eql(x1, 2) 
      && Nat.eql(y1, 0) 
      && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(1, board[4] <> Bits.e)))
 
  let black_r =
    Nat.eql(x0, 4) 
    && Nat.eql(y0, 0) 
    && Bits.eql(Bits.i(Bits.e), Bits.slice(1, king_tile))
    && Bits.eql(empty_tile, get_tile(5, 0))
    && Bits.eql(empty_tile, get_tile(6, 0))
    && Nat.eql(x1, 6) 
    && Nat.eql(y1, 0) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(2, board[4] <> Bits.e)))
  
  let white_l =
    Nat.eql(x0, 4) 
    && Nat.eql(y0, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, king_tile)) 
    && Bits.eql(empty_tile, get_tile(3, 7))
    && Bits.eql(empty_tile, get_tile(2, 7))
    && Bits.eql(empty_tile, get_tile(1, 7))
    && Nat.eql(x1, 2) 
    && Nat.eql(y1, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(3, board[4] <> Bits.e)))
    
  let white_r =
    Nat.eql(x0, 4) 
    && Nat.eql(y0, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, king_tile)) 
    && Bits.eql(empty_tile, get_tile(5, 7))
    && Bits.eql(empty_tile, get_tile(6, 7))
    && Nat.eql(x1, 6) 
    && Nat.eql(y1, 7) 
    && Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(4, board[4] <> Bits.e)))

  black_l || black_r || white_l || white_r


App.Chess.is_move_possible_pawn(x0: Nat, y0: Nat, x1: Nat, y1: Nat, is_to_tile_empty: Bool, piece_owner: Bits, board: App.Chess.Board) : Bool
  if Bits.eql(piece_owner, Bits.o(Bits.e)) then
    if is_to_tile_empty then 
      if Nat.eql(y0, 6) then 
        Nat.eql(x0, x1) && (Nat.eql((y0 - y1), 1) || (Nat.eql((y0 - y1), 2) && Bits.eql(App.Chess.get(x0, y0 - 1, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))))
      else
        Nat.eql(x0, x1) && Nat.eql((y0 - y1), 1)
    else
      (Nat.eql(x0 - x1, 1) || Nat.eql(x1 - x0, 1)) && Nat.eql((y0 - y1), 1)
  else 
    if is_to_tile_empty then
      if Nat.eql(y0, 1) then
        Nat.eql(x0, x1) && (Nat.eql((y1 - y0), 1) || (Nat.eql((y1 - y0), 2) && Bits.eql(App.Chess.get(x0, y0 + 1, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))))
      else
        Nat.eql(x0, x1) && Nat.eql((y1 - y0), 1)
    else
      (Nat.eql(x1 - x0, 1) || Nat.eql(x0 - x1, 1)) && Nat.eql((y1 - y0), 1)
    
App.Chess.is_move_possible_rook(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  if Bool.not(Nat.eql(x0, x1) || Nat.eql(y0, y1)) then
    false
  else
    if Nat.ltn(x0, x1) then
      App.Chess.is_move_possible_rook_aux1(x0 + 1, y0, x1 - 1, y1, board)
    else if Nat.ltn(x1, x0) then
      App.Chess.is_move_possible_rook_aux2(x0 - 1, y0, x1 + 1, y1, board)
    else if Nat.ltn(y0, y1) then
      App.Chess.is_move_possible_rook_aux3(x0, y0 + 1, x1, y1 - 1, board)
    else
      App.Chess.is_move_possible_rook_aux4(x0, y0 - 1, x1, y1 + 1, board)

App.Chess.is_move_possible_rook_aux1(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  if Nat.gtn(x0, x1) then
    true
  else 
    if Bits.eql(App.Chess.get(x1, y1, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
    && Bits.eql(App.Chess.get(x0, y0, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_move_possible_rook_aux1(x0 + 1, y0, x1 - 1, y1, board)
    else
      false

App.Chess.is_move_possible_rook_aux2(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  if Nat.ltn(x0, x1) then
    true
  else 
    if Bits.eql(App.Chess.get(x1, y1, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
    && Bits.eql(App.Chess.get(x0, y0, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_move_possible_rook_aux2(x0 - 1, y0, x1 + 1, y1, board)
    else
      false

App.Chess.is_move_possible_rook_aux3(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  if Nat.gtn(y0, y1) then
    true
  else 
    if Bits.eql(App.Chess.get(x1, y1, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
    && Bits.eql(App.Chess.get(x0, y0, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_move_possible_rook_aux3(x0, y0 + 1, x1, y1 - 1, board)
    else
      false
  
App.Chess.is_move_possible_rook_aux4(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  if Nat.ltn(y0, y1) then
    true
  else 
    if Bits.eql(App.Chess.get(x1, y1, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
    && Bits.eql(App.Chess.get(x0, y0, board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_move_possible_rook_aux4(x0, y0 - 1, x1, y1 + 1, board)
    else
      false


App.Chess.is_move_possible_knight(x0: Int, y0: Int, x1: Int, y1: Int, board: App.Chess.Board): Bool
  (Nat.eql(Int.abs(x0 - x1), 2) && Nat.eql(Int.abs(y0 - y1), 1)) || (Nat.eql(Int.abs(x0 - x1), 1) && Nat.eql(Int.abs(y0 - y1), 2))

App.Chess.is_move_possible_bishop(x0: Int, y0: Int, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Bool.not(Nat.eql(Int.abs(x0 - x1), Int.abs(y0 - y1))) then
    false
  else
    if Int.ltn(x0, x1) && Int.ltn(y0, y1) then
      App.Chess.is_move_possible_bishop_aux1(x0 + 1, y0 + 1, x1 - 1, y1 - 1, board)   
    else if Int.ltn(x0, x1) && Int.ltn(y1, y0) then
      App.Chess.is_move_possible_bishop_aux2(x0 + 1, y0 - 1, x1 - 1, y1 + 1, board)
    else if Int.ltn(x1, x0) && Int.ltn(y0, y1) then
      App.Chess.is_move_possible_bishop_aux3(x0 - 1, y0 + 1, x1 + 1, y1 - 1, board)
    else
      App.Chess.is_move_possible_bishop_aux4(x0 - 1, y0 - 1, x1 + 1, y1 + 1, board)

App.Chess.is_move_possible_bishop_aux1(x0: Int, y0: Int, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x0, x1) then
    true
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))
      && Bits.eql(App.Chess.get(Int.to_nat(x0), Int.to_nat(y0), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_move_possible_bishop_aux1(x0 + 1, y0 + 1, x1 - 1, y1 - 1, board)
    else
      false

App.Chess.is_move_possible_bishop_aux2(x0: Int, y0: Int, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x0, x1) then
    true
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) 
      && Bits.eql(App.Chess.get(Int.to_nat(x0), Int.to_nat(y0), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_move_possible_bishop_aux2(x0 + 1, y0 - 1, x1 - 1, y1 + 1, board)
    else
      false

App.Chess.is_move_possible_bishop_aux3(x0: Int, y0: Int, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x1, x0) then
    true
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) 
      && Bits.eql(App.Chess.get(Int.to_nat(x0), Int.to_nat(y0), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_move_possible_bishop_aux3(x0 - 1, y0 + 1, x1 + 1, y1 - 1, board)
    else
      false

App.Chess.is_move_possible_bishop_aux4(x0: Int, y0: Int, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x1, x0) then
    true
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) 
      && Bits.eql(App.Chess.get(Int.to_nat(x0), Int.to_nat(y0), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_move_possible_bishop_aux4(x0 - 1, y0 - 1, x1 + 1, y1 + 1, board)
    else
      false

App.Chess.is_move_possible_queen(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): Bool
  App.Chess.is_move_possible_rook(x0, y0, x1, y1, board) 
  || App.Chess.is_move_possible_bishop(Nat.to_int(x0), Nat.to_int(y0), Nat.to_int(x1), Nat.to_int(y1), board)

App.Chess.is_move_possible_king(x0: Int, y0: Int, x1: Int, y1: Int, board: App.Chess.Board): Bool
  Nat.lte(Int.abs(x0 - x1), 1) && Nat.lte(Int.abs(y0 - y1), 1)


App.Chess.move(code: Bits, board: App.Chess.Board): App.Chess.Board
  let team = Bits.slice(1,code)
  let x0   = Bits.slice(3,Bits.drop(1,code))
  let y0   = Bits.slice(3,Bits.drop(4,code))
  let x1   = Bits.slice(3,Bits.drop(7,code))
  let y1   = Bits.slice(3,Bits.drop(10,code))
  let is_possible = App.Chess.is_move_possible(Bits.to_nat(x0), Bits.to_nat(y0), Bits.to_nat(x1), Bits.to_nat(y1), team, board)
  if is_possible then App.Chess.move.aux(Bits.to_nat(x0), Bits.to_nat(y0), Bits.to_nat(x1), Bits.to_nat(y1), team, board) else board

App.Chess.move.aux(x0: Nat, y0: Nat, x1: Nat, y1: Nat, team: Bits, board: App.Chess.Board): App.Chess.Board
  let tile_size  = 4 :: Nat
  let from_index = (x0 * tile_size) + (y0 * 8 * tile_size)
  let from_chunk = App.Chess.get_chunk(from_index, board) 
  let from_tile  = Bits.slice(4, Bits.drop(56 - from_index % 60, from_chunk))
  let new_tile   = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  let from_chunk = Bits.set(56 - from_index % 60, new_tile, from_chunk)
  let new_board = 
    if from_index <? 60 then
        board[0] <- from_chunk 
      else if from_index <? 120 then  
        board[1] <- from_chunk
      else if from_index <? 180 then
        board[2] <- from_chunk
      else if from_index <? 240 then
        board[3] <- from_chunk
      else
        board[4] <- from_chunk

  // Pawn Promotion
  let from_tile =
    if Bits.eql(from_tile, Bits.i(Bits.i(Bits.o(Bits.o(Bits.e))))) && Nat.eql(y1, 7) then
      Bits.i(Bits.i(Bits.o(Bits.i(Bits.e))))
    else
      if Bits.eql(from_tile, Bits.o(Bits.i(Bits.o(Bits.o(Bits.e))))) && Nat.eql(y1, 0) then
        Bits.o(Bits.i(Bits.o(Bits.i(Bits.e))))
      else
        from_tile
  
  let to_index = (x1 * tile_size) + (y1 * 8 * tile_size)
  let to_chunk = App.Chess.get_chunk(to_index, new_board)
  let to_chunk = Bits.set(56 - to_index % 60, from_tile, to_chunk)
  let new_board = 
    if to_index <? 60 then
        new_board[0] <- to_chunk 
      else if to_index <? 120 then  
        new_board[1] <- to_chunk
      else if to_index <? 180 then
        new_board[2] <- to_chunk
      else if to_index <? 240 then
        new_board[3] <- to_chunk
      else
        new_board[4] <- to_chunk

  

  let new_board = App.Chess.castle(x1, y1, new_board)

  let new_board = App.Chess.set_castle_bits(x0, y0, new_board)
     
  log(List.show!(Bits.show, new_board)) 
  log(Bool.show(App.Chess.is_castle_possible(4, 0, 2, 0, board)))
  log(Bool.show(App.Chess.is_castle_possible(4, 0, 6, 0, board)))
  log(Bool.show(App.Chess.is_castle_possible(4, 7, 2, 7, board)))
  log(Bool.show(App.Chess.is_castle_possible(4, 7, 6, 7, board)))


  
  let is_check = App.Chess.in_check(team, board)  
  if is_check then
    let still_check =  App.Chess.in_check(team, new_board)
    if still_check then 
      board
    else
      let last_chunk = new_board[4]
      let new_board = 
      case last_chunk {
        none: new_board
        some: 
          let last_chunk = Bits.set(0, Bits.not(team), last_chunk.value)
          //let last_chunk = Bits.set(5, Bits.o(Bits.e), last_chunk)
          let new_board = new_board[4] <- last_chunk
          new_board
      }
      new_board
  else  
    let will_in_check = App.Chess.in_check(team, new_board)
    if will_in_check then
      board
    else
      let last_chunk = new_board[4]
      let new_board = 
      case last_chunk {
        none: new_board
        some: 
          let last_chunk = Bits.set(0, Bits.not(team), last_chunk.value)
          //let last_chunk = Bits.set(5, Bits.o(Bits.e), last_chunk)
          let new_board = new_board[4] <- last_chunk
          new_board
      }
      new_board          
 

App.Chess.in_check(team: Bits, board: App.Chess.Board): Bool
  let white_king = Bits.o(Bits.o(Bits.i(Bits.i(Bits.e))))
  let {xw, yw} = App.Chess.find_piece(white_king, board) <> Pair.new!!<8,8>

  let black_king = Bits.i(Bits.o(Bits.i(Bits.i(Bits.e))))
  let {xb, yb} = App.Chess.find_piece(black_king, board) <> Pair.new!!<8,8>
    
  if Bits.eql(Bits.o(Bits.e), team) then
    App.Chess.is_checked(xw, yw, board)
  else
    App.Chess.is_checked(xb, yb, board)

App.Chess.castle_move_rook(x0: Nat, y0: Nat, x1: Nat, y1: Nat, board: App.Chess.Board): App.Chess.Board
  let tile_size  = 4 :: Nat
  let from_index = (x0 * tile_size) + (y0 * 8 * tile_size)
  let from_chunk = App.Chess.get_chunk(from_index, board) 
  let from_tile = Bits.slice(4, Bits.drop(56 - from_index % 60, from_chunk))
  let new_tile = Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
  let from_chunk = Bits.set(56 - from_index % 60, new_tile, from_chunk)
  let new_board = 
    if from_index <? 60 then
        board[0] <- from_chunk 
      else if from_index <? 120 then  
        board[1] <- from_chunk
      else if from_index <? 180 then
        board[2] <- from_chunk
      else if from_index <? 240 then
        board[3] <- from_chunk
      else
        board[4] <- from_chunk

  let to_index = (x1 * tile_size) + (y1 * 8 * tile_size)
  let to_chunk = App.Chess.get_chunk(to_index, new_board)
  let to_chunk = Bits.set(56 - to_index % 60, from_tile, to_chunk)
  let new_board = 
    if to_index <? 60 then
        new_board[0] <- to_chunk 
      else if to_index <? 120 then  
        new_board[1] <- to_chunk
      else if to_index <? 180 then
        new_board[2] <- to_chunk
      else if to_index <? 240 then
        new_board[3] <- to_chunk
      else
        new_board[4] <- to_chunk
  new_board

App.Chess.castle(x1: Nat, y1: Nat, board: App.Chess.Board): App.Chess.Board
  let piece         = App.Chess.get(x1, y1, board)
  let piece1        = App.Chess.get(0, 0, board)
  let piece2        = App.Chess.get(7, 0, board)
  let piece3        = App.Chess.get(0, 7, board)
  let piece4        = App.Chess.get(7, 7, board)
  let black_rook    = Bits.i(Bits.o(Bits.i(Bits.o(Bits.e))))
  let white_rook    = Bits.o(Bits.o(Bits.i(Bits.o(Bits.e))))
  let is_black_king = Bits.eql(piece, Bits.i(Bits.o(Bits.i(Bits.i(Bits.e)))))
  let is_white_king = Bits.eql(piece, Bits.o(Bits.o(Bits.i(Bits.i(Bits.e)))))
  let is_possible   = (i: Nat) Bits.eql(Bits.o(Bits.e), Bits.slice(1, Bits.drop(i, board[4] <> Bits.e)))
  log(Bits.show(piece))
  if is_black_king then
    if Nat.eql(x1, 2) && Nat.eql(y1, 0) && is_possible(1) && Bits.eql(piece1, black_rook) then
      App.Chess.castle_move_rook(0, 0, 3, 0, board)
    else  
      if Nat.eql(x1, 6) && Nat.eql(y1, 0) && is_possible(2) && Bits.eql(piece2, black_rook) then
        App.Chess.castle_move_rook(7, 0, 5, 0, board)
      else 
        board
  else
    if is_white_king then
      if Nat.eql(x1, 2) && Nat.eql(y1, 7) && is_possible(3) && Bits.eql(piece3, white_rook) then
        App.Chess.castle_move_rook(0, 7, 3, 7, board)
      else  
        if Nat.eql(x1, 6) && Nat.eql(y1, 7) && is_possible(4) && Bits.eql(piece4, white_rook) then
          App.Chess.castle_move_rook(7, 7, 5, 7, board)
        else 
          board 
    else
      board

App.Chess.set_castle_bits(x0: Nat, y0: Nat, board: App.Chess.Board): App.Chess.Board  
  if Nat.eql(x0, 4) && Nat.eql(y0, 0) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(1, Bits.i(Bits.e), last_chunk.value)
          let last_chunk = Bits.set(2, Bits.i(Bits.e), last_chunk)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 4) && Nat.eql(y0, 7) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(3, Bits.i(Bits.e), last_chunk.value)
          let last_chunk = Bits.set(4, Bits.i(Bits.e), last_chunk)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 0) && Nat.eql(y0, 0) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(1, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 7) && Nat.eql(y0, 0) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(2, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 0) && Nat.eql(y0, 7) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(3, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board

  else if Nat.eql(x0, 7) && Nat.eql(y0, 7) then
    let last_chunk = board[4]
    let board = 
      case last_chunk {
        none: board
        some: 
          let last_chunk = Bits.set(4, Bits.i(Bits.e), last_chunk.value)
          board[4] <- last_chunk
    }
    board
  else
    board

App.Chess.find_piece(piece: Bits, board: App.Chess.Board) : Maybe<Pair<Nat, Nat>>
  App.Chess.find_piece_aux(0, piece, board)

App.Chess.find_piece_aux(index: Nat, piece: Bits, board: App.Chess.Board) : Maybe<Pair<Nat, Nat>>
  let x = (index / 4) % 8
  let y = index / 32
  if Nat.gtn(index, 256) then 
    none
  else
    if Bits.eql(App.Chess.get(x, y, board), piece) then
      some(Pair.new!!(x, y))
  else
    App.Chess.find_piece_aux(index + 4, piece, board)

App.Chess.is_checked(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let straight = App.Chess.is_checked_straight(x0, y0, board) 
  let diagonal = App.Chess.is_checked_diagonal(x0, y0, board) 
  let knight   = App.Chess.is_checked_knight(x0, y0, board)
  let pawn     = App.Chess.is_checked_pawn(x0, y0, board)
  straight || diagonal || knight || pawn 

App.Chess.is_checked_straight(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let x1 = Nat.to_int(x0)
  let y1 = Nat.to_int(y0)
  let up    = App.Chess.is_checked_straight_up(x0, y0, x1, y1 - 1, board)
  let down  = App.Chess.is_checked_straight_down(x0, y0, x1, y1 + 1, board)
  let left  = App.Chess.is_checked_straight_left(x0, y0, x1 - 1, y1, board)
  let right = App.Chess.is_checked_straight_right(x0, y0, x1 + 1, y1, board)
  up || down || left || right


App.Chess.is_checked_straight_up(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool 
  if Int.ltn(y1, 0) then
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_checked_straight_up(x0, y0, x1, y1 - 1, board)
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.o(Bits.i(Bits.e))))
        || Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.o(Bits.i(Bits.o(Bits.e))))


App.Chess.is_checked_straight_down(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool 
  if Int.gtn(y1, 7) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then 
      App.Chess.is_checked_straight_down(x0, y0, x1, y1 + 1, board)
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.o(Bits.i(Bits.e)))) 
        || Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.o(Bits.i(Bits.o(Bits.e))))


App.Chess.is_checked_straight_left(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool 
  if Int.ltn(x1, 0) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then 
      App.Chess.is_checked_straight_left(x0, y0, x1 - 1, y1, board)
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.o(Bits.i(Bits.e)))) 
        || Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.o(Bits.i(Bits.o(Bits.e))))

App.Chess.is_checked_straight_right(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x1, 7) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then 
      App.Chess.is_checked_straight_right(x0, y0, x1 + 1, y1, board)
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.o(Bits.i(Bits.e)))) 
        || Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.o(Bits.i(Bits.o(Bits.e))))



App.Chess.is_checked_diagonal(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let x1 = Nat.to_int(x0)
  let y1 = Nat.to_int(y0)
  let aux1  = App.Chess.is_checked_diagonal_aux1(x0, y0, x1 + 1, y1 - 1, board) //1Q
  let aux2  = App.Chess.is_checked_diagonal_aux2(x0, y0, x1 - 1, y1 - 1, board) //2Q
  let aux3  = App.Chess.is_checked_diagonal_aux3(x0, y0, x1 - 1, y1 + 1, board) //3Q
  let aux4  = App.Chess.is_checked_diagonal_aux4(x0, y0, x1 + 1, y1 + 1, board) //4Q
  aux1 || aux2 || aux3 || aux4



App.Chess.is_checked_diagonal_aux1(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x1, 7) || Int.ltn(y1, 0) then
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then
      App.Chess.is_checked_diagonal_aux1(x0, y0, x1 + 1, y1 - 1, board)
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.o(Bits.o(Bits.i(Bits.e)))) 
        || Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.o(Bits.i(Bits.e))))

App.Chess.is_checked_diagonal_aux2(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.ltn(x1, 0) || Int.ltn(y1, 0) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      App.Chess.is_checked_diagonal_aux2(x0, y0, x1 - 1, y1 - 1, board)
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.o(Bits.o(Bits.i(Bits.e)))) 
        || Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.o(Bits.i(Bits.e))))


App.Chess.is_checked_diagonal_aux3(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.ltn(x1, 0) || Int.gtn(y1, 7) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      App.Chess.is_checked_diagonal_aux3(x0, y0, x1 - 1, y1 + 1, board)
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.o(Bits.o(Bits.i(Bits.e)))) 
        || Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.o(Bits.i(Bits.e))))

App.Chess.is_checked_diagonal_aux4(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x1, 7) || Int.gtn(y1, 7) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      App.Chess.is_checked_diagonal_aux4(x0, y0, x1 + 1, y1 + 1, board)
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.o(Bits.o(Bits.i(Bits.e)))) 
        || Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.o(Bits.i(Bits.e))))


App.Chess.is_checked_knight(x0: Nat, y0: Nat, board: App.Chess.Board): Bool 
  let x1 = Nat.to_int(x0)
  let y1 = Nat.to_int(y0)
  let aux1 = App.Chess.is_checked_knight_aux1(x0, y0, x1 + 1, y1 + 2, board)
  let aux2 = App.Chess.is_checked_knight_aux2(x0, y0, x1 + 1, y1 - 2, board)
  let aux3 = App.Chess.is_checked_knight_aux3(x0, y0, x1 - 1, y1 + 2, board)
  let aux4 = App.Chess.is_checked_knight_aux4(x0, y0, x1 - 1, y1 - 2, board)
  let aux5 = App.Chess.is_checked_knight_aux5(x0, y0, x1 + 2, y1 + 1, board)
  let aux6 = App.Chess.is_checked_knight_aux6(x0, y0, x1 + 2, y1 - 1, board)
  let aux7 = App.Chess.is_checked_knight_aux7(x0, y0, x1 - 2, y1 + 1, board)
  let aux8 = App.Chess.is_checked_knight_aux8(x0, y0, x1 - 2, y1 - 1, board)
  aux1 || aux2 || aux3 || aux4 || aux5 || aux6 || aux7 || aux8



App.Chess.is_checked_knight_aux1(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x1, 7) || Int.gtn(y1, 7) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      false
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.i(Bits.o(Bits.e))))

App.Chess.is_checked_knight_aux2(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x1, 7) || Int.ltn(y1, 0) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      false
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.i(Bits.o(Bits.e))))


App.Chess.is_checked_knight_aux3(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.ltn(x1, 0) || Int.gtn(y1, 7) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      false
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.i(Bits.o(Bits.e))))

App.Chess.is_checked_knight_aux4(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.ltn(x1, 0) || Int.ltn(y1, 0) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      false
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.i(Bits.o(Bits.e)))) 


App.Chess.is_checked_knight_aux5(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x1, 7) || Int.gtn(y1, 7) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      false
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.i(Bits.o(Bits.e))))


App.Chess.is_checked_knight_aux6(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.gtn(x1, 7) || Int.ltn(y1, 0) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      false
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.i(Bits.o(Bits.e)))) 


App.Chess.is_checked_knight_aux7(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.ltn(x1, 0) || Int.gtn(y1, 7) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      false
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.i(Bits.o(Bits.e))))
  
App.Chess.is_checked_knight_aux8(x0: Nat, y0: Nat, x1: Int, y1: Int, board: App.Chess.Board): Bool
  if Int.ltn(x1, 0) || Int.ltn(y1, 0) then 
    false      
  else
    if Bits.eql(App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board), Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))) then  
      false
    else 
      if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.slice(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board))) then 
        false
      else
        Bits.eql(Bits.drop(1, App.Chess.get(Int.to_nat(x1), Int.to_nat(y1), board)), Bits.i(Bits.i(Bits.o(Bits.e))))


App.Chess.is_checked_pawn(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  if Bits.eql(Bits.slice(1, App.Chess.get(x0, y0, board)), Bits.o(Bits.e)) then
    App.Chess.is_checked_pawn_white(x0, y0, board)
  else
    App.Chess.is_checked_pawn_black(x0, y0, board)

App.Chess.is_checked_pawn_white(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let tile1 = App.Chess.get(x0 - 1, y0 - 1, board)
  let tile2 = App.Chess.get(x0 + 1, y0 - 1, board)
  let black_pawn = Bits.i(Bits.i(Bits.o(Bits.o(Bits.e))))
  Bits.eql(tile1, black_pawn) || Bits.eql(tile2, black_pawn)

App.Chess.is_checked_pawn_black(x0: Nat, y0: Nat, board: App.Chess.Board): Bool
  let tile1 = App.Chess.get(x0 - 1, y0 + 1, board)
  let tile2 = App.Chess.get(x0 + 1, y0 + 1, board)
  let white_pawn = Bits.o(Bits.i(Bits.o(Bits.o(Bits.e))))
  Bits.eql(tile1, white_pawn) || Bits.eql(tile2, white_pawn)


App.Chess.mouse_to_coord(mouse_pos: Pair<U32, U32>): Pair<Nat, Nat>
  let scale     = App.Chess.scale
  let tile_size = App.Chess.tile_size
  let x = mouse_pos@fst / (scale * tile_size)
  let y = mouse_pos@snd / (scale * tile_size)
  {U32.to_nat(x), U32.to_nat(y)}

// Event handler
App.Chess.when: App.When<App.Chess.State>
  (event, state)
  let local = state@local
  let global = state@global
  let room = String.take(16, Crypto.Keccak.hash(App.Chess.room))
  case event {
    init: App.watch!(room)
    mouse_down:
      let selected = local@selected
      let coord = App.Chess.mouse_to_coord(local@mouse_pos)
      case selected {
        none:
          open coord
            let local = local@selected <- some(coord)
            App.set_local!(local)
        some: 
          let {x0, y0} = selected.value
          let {x1, y1} = coord
          let is_possible = App.Chess.is_move_possible(x0, y0, x1, y1, local@team, global)
          let f = (x: Nat) Bits.trim(3, Nat.to_bits(x)) 
          if is_possible then
            let code = Bits.concat(local@team, Bits.concat(f(x0), Bits.concat(f(y0), Bits.concat(f(x1), f(y1))))) 
            let code = Bits.show(code)
            let new_team = Bits.not(local@team)
            let same_team = local@team 
            IO {
              App.new_post!(room, code)
              let local = local@selected <- none
              let code1 = Bits.concat(local@team, Bits.concat(f(x0), Bits.concat(f(y0), Bits.concat(f(x1), f(y1)))))              
              let board = App.Chess.move(code1, global)
              log("board: " | List.show!(Bits.show, board))
              log("Global: " | List.show!(Bits.show, state@global))
              log("Igual: " | Bool.show(List.eql!(Bits.eql, board, state@global)))
              let local =
                if List.eql!(Bits.eql, board, state@global) then
                  local@team  <- same_team
                else
                  local@team <- new_team              
            App.set_local!(local)
            
            }
          else  
            App.set_local!(local@selected <- none)
        }
    mouse_move:
      let local = local@mouse_pos <- event.mouse_pos
      App.set_local!(local)
  } default App.pass!


// Global ticker 
App.Chess.tick: App.Tick<App.Chess.State>
  App.no_tick<App.Chess.State>

App.Chess.post: App.Post<App.Chess.State>
  (time, room, addr, data, glob)
  let code = Bits.read(data)
  // App.Chess.move(code, glob)
  case code {
    o: 
      App.Chess.move(code.pred, glob)
  } default glob
  
App.Chess: App<App.Chess.State>
  let img = VoxBox.alloc_capacity(65536*8)
  App.new<App.Chess.State>(
    App.Chess.init
    App.Chess.draw(img)
    App.Chess.when
    App.Chess.tick
    App.Chess.post
  )
